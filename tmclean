#!/usr/bin/env perl
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/tmclean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TMCLEAN';
  package App::tmclean;use 5.010;use warnings;use version 0.77;our$VERSION=version->declare("v0.0.3");use Getopt::Long qw/GetOptions :config posix_default no_ignore_case bundling auto_help/;use Pod::Usage qw/pod2usage/;use Class::Accessor::Lite (new=>1,ro=>[qw/before days dry_run/],);use HTTP::Date qw/str2time/;use Time::Piece ();use Time::Seconds ();sub logf {my$msg=shift;$msg=sprintf($msg,@_);my$prefix='[tmclean]' .Time::Piece->localtime->strftime('[%Y-%m-%d %H:%M:%S] ');$msg .= "\n" if$msg !~ /\n$/;print STDERR$prefix .$msg}sub new_with_options {my ($class,@argv)=@_;my ($opt)=$class->parse_options(@argv);$class->new($opt)}sub parse_options {my ($class,@argv)=@_;local@ARGV=@argv;GetOptions(\my%opt,qw/days=i before=s dry-run/)or pod2usage(2);$opt{dry_run}=delete$opt{'dry-run'};return (\%opt,\@ARGV)}sub run {my$self=shift;if (!$self->dry_run && $ENV{USER}ne 'root'){die "tmutil requires root privileges\n"}$self->cmd(qw/tmutil stopbackup/);$self->cmd(qw/tmutil disable/);my@targets=$self->backups2delete;unless (@targets){logf 'no deletion targets found';return 0}my$mount_point=$self->mount_point;logf "following backups to be deleted:\n  %s",join("\n  ",@targets);for my$bak (@targets){$self->cmd(qw/tmutil delete/,$bak)}my$dev_name=dev_name($targets[0]);$self->cmd(qw/hdiutil detach/,$dev_name);my$sparsebundle_path=sprintf '%s/%s.sparsebundle',$mount_point,$self->machine_name;$self->cmd(qw/hdiutil compact/,$sparsebundle_path);$self->cmd(qw/tmutil enable/)}sub backups2delete {my$self=shift;my@backups=`tmutil listbackups`;if ($?!=0){die "failed to execute `tmutil listbackups`: $?\n"}return grep {chomp;my@paths=split m!/!,$_;my$backup_date=eval {Time::Piece->strptime($paths[-1],'%Y-%m-%d-%H%M%S')};$backup_date && $self->before_tp > $backup_date}@backups}sub mount_point {my$self=shift;$self->{mount_point}||= sub {my@lines=`tmutil destinationinfo`;if ($?!=0){die "failed to execute `tmutil destinationinfo`: $?\n"}for my$line (@lines){chomp$line;my ($key,$val)=split /\s+:\s+/,$line,2;if ($key eq 'Mount Point'){return$val}}die "no mount points found\n"}->()}sub dev_name {my$path=shift;my@paths=split m!/!,$path;join '/',@paths[0..2]}sub machine_name {my$self=shift;$self->{machine_name}||= do {chomp(my$hostname=`hostname`);if ($?!=0){die "failed to execute `hostname`: $?\n"}$hostname =~ s/\.local$//;$hostname}}sub before_tp {my$self=shift;$self->{before_tp}||= sub {if ($self->before){my$time=str2time$self->before;die "unrecognized date format @{[$self->before]}" unless$time;return Time::Piece->localtime($time)}my$days=$self->days || 366;return Time::Piece->localtime()- Time::Seconds::ONE_DAY()* $days}->()}sub cmd {my ($self,@command)=@_;my$cmd_str=join(' ',@command);logf 'execute%s: `%s`',$self->dry_run ? '(dry-run)' : '',$cmd_str;if (!$self->dry_run){!system(@command)or die "failed to execute command: $cmd_str: $?\n"}}1;
APP_TMCLEAN

$fatpacked{"Class/Accessor/Lite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_ACCESSOR_LITE';
  package Class::Accessor::Lite;use strict;our$VERSION='0.08';sub croak {require Carp;Carp::croak(@_)}sub import {shift;my%args=@_;my$pkg=caller(0);my%key_ctor=(rw=>\&_mk_accessors,ro=>\&_mk_ro_accessors,wo=>\&_mk_wo_accessors,);for my$key (sort keys%key_ctor){if (defined$args{$key}){croak("value of the '$key' parameter should be an arrayref")unless ref($args{$key})eq 'ARRAY';$key_ctor{$key}->($pkg,@{$args{$key}})}}_mk_new($pkg)if$args{new};1}sub mk_new_and_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_new($pkg);_mk_accessors($pkg,@properties)}sub mk_new {my$pkg=caller(0);_mk_new($pkg)}sub mk_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_accessors($pkg,@properties)}sub mk_ro_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_ro_accessors($pkg,@properties)}sub mk_wo_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_wo_accessors($pkg,@properties)}sub _mk_new {my$pkg=shift;no strict 'refs';*{$pkg .'::new'}=__m_new($pkg)}sub _mk_accessors {my$pkg=shift;no strict 'refs';for my$n (@_){*{$pkg .'::' .$n}=__m($n)}}sub _mk_ro_accessors {my$pkg=shift;no strict 'refs';for my$n (@_){*{$pkg .'::' .$n}=__m_ro($pkg,$n)}}sub _mk_wo_accessors {my$pkg=shift;no strict 'refs';for my$n (@_){*{$pkg .'::' .$n}=__m_wo($pkg,$n)}}sub __m_new {my$pkg=shift;no strict 'refs';return sub {my$klass=shift;bless {(@_==1 && ref($_[0])eq 'HASH' ? %{$_[0]}: @_),},$klass}}sub __m {my$n=shift;sub {return $_[0]->{$n}if @_==1;return $_[0]->{$n}=$_[1]if @_==2;shift->{$n}=\@_}}sub __m_ro {my ($pkg,$n)=@_;sub {if (@_==1){return $_[0]->{$n}if @_==1}else {my$caller=caller(0);croak("'$caller' cannot access the value of '$n' on objects of class '$pkg'")}}}sub __m_wo {my ($pkg,$n)=@_;sub {if (@_==1){my$caller=caller(0);croak("'$caller' cannot alter the value of '$n' on objects of class '$pkg'")}else {return $_[0]->{$n}=$_[1]if @_==2;shift->{$n}=\@_}}}1;
CLASS_ACCESSOR_LITE

$fatpacked{"HTTP/Date.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_DATE';
  package HTTP::Date;$VERSION="6.02";require Exporter;@ISA=qw(Exporter);@EXPORT=qw(time2str str2time);@EXPORT_OK=qw(parse_date time2iso time2isoz);use strict;require Time::Local;use vars qw(@DoW @MoY %MoY);@DoW=qw(Sun Mon Tue Wed Thu Fri Sat);@MoY=qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);@MoY{@MoY}=(1..12);my%GMT_ZONE=(GMT=>1,UTC=>1,UT=>1,Z=>1);sub time2str (;$) {my$time=shift;$time=time unless defined$time;my ($sec,$min,$hour,$mday,$mon,$year,$wday)=gmtime($time);sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",$DoW[$wday],$mday,$MoY[$mon],$year+1900,$hour,$min,$sec)}sub str2time ($;$) {my$str=shift;return undef unless defined$str;if ($str =~ /^[SMTWF][a-z][a-z], (\d\d) ([JFMAJSOND][a-z][a-z]) (\d\d\d\d) (\d\d):(\d\d):(\d\d) GMT$/){return eval {my$t=Time::Local::timegm($6,$5,$4,$1,$MoY{$2}-1,$3);$t < 0 ? undef : $t}}my@d=parse_date($str);return undef unless@d;$d[1]--;my$tz=pop(@d);unless (defined$tz){unless (defined($tz=shift)){return eval {my$frac=$d[-1];$frac -= ($d[-1]=int($frac));my$t=Time::Local::timelocal(reverse@d)+ $frac;$t < 0 ? undef : $t}}}my$offset=0;if ($GMT_ZONE{uc$tz}){}elsif ($tz =~ /^([-+])?(\d\d?):?(\d\d)?$/){$offset=3600 * $2;$offset += 60 * $3 if $3;$offset *= -1 if $1 && $1 eq '-'}else {eval {require Time::Zone}|| return undef;$offset=Time::Zone::tz_offset($tz);return undef unless defined$offset}return eval {my$frac=$d[-1];$frac -= ($d[-1]=int($frac));my$t=Time::Local::timegm(reverse@d)+ $frac;$t < 0 ? undef : $t - $offset}}sub parse_date ($) {local($_)=shift;return unless defined;s/^\s+//;s/^(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)[a-z]*,?\s*//i;my($day,$mon,$yr,$hr,$min,$sec,$tz,$ampm);(($day,$mon,$yr,$hr,$min,$sec,$tz)=/^
  	 (\d\d?)               # day
  	    (?:\s+|[-\/])
  	 (\w+)                 # month
  	    (?:\s+|[-\/])
  	 (\d+)                 # year
  	 (?:
  	       (?:\s+|:)       # separator before clock
  	    (\d\d?):(\d\d)     # hour:min
  	    (?::(\d\d))?       # optional seconds
  	 )?                    # optional clock
  	    \s*
  	 ([-+]?\d{2,4}|(?![APap][Mm]\b)[A-Za-z]+)? # timezone
  	    \s*
  	 (?:\(\w+\)|\w{3,})?   # ASCII representation of timezone.
  	    \s*$
  	/x)|| (($mon,$day,$hr,$min,$sec,$tz,$yr)=/^
  	 (\w{1,3})             # month
  	    \s+
  	 (\d\d?)               # day
  	    \s+
  	 (\d\d?):(\d\d)        # hour:min
  	 (?::(\d\d))?          # optional seconds
  	    \s+
  	 (?:([A-Za-z]+)\s+)?   # optional timezone
  	 (\d+)                 # year
  	    \s*$               # allow trailing whitespace
  	/x)|| (($mon,$day,$yr,$hr,$min,$sec)=/^
  	 (\w{3})               # month
  	    \s+
  	 (\d\d?)               # day
  	    \s+
  	 (?:
  	    (\d\d\d\d) |       # year
  	    (\d{1,2}):(\d{2})  # hour:min
              (?::(\d\d))?       # optional seconds
  	 )
  	 \s*$
         /x)|| (($yr,$mon,$day,$hr,$min,$sec,$tz)=/^
  	  (\d{4})              # year
  	     [-\/]?
  	  (\d\d?)              # numerical month
  	     [-\/]?
  	  (\d\d?)              # day
  	 (?:
  	       (?:\s+|[-:Tt])  # separator before clock
  	    (\d\d?):?(\d\d)    # hour:min
  	    (?::?(\d\d(?:\.\d*)?))?  # optional seconds (and fractional)
  	 )?                    # optional clock
  	    \s*
  	 ([-+]?\d\d?:?(:?\d\d)?
  	  |Z|z)?               # timezone  (Z is "zero meridian", i.e. GMT)
  	    \s*$
  	/x)|| (($mon,$day,$yr,$hr,$min,$ampm)=/^
            (\d{2})                # numerical month
               -
            (\d{2})                # day
               -
            (\d{2})                # year
               \s+
            (\d\d?):(\d\d)([APap][Mm])  # hour:min AM or PM
               \s*$
          /x)|| return;$mon=$MoY{$mon}|| $MoY{"\u\L$mon"}|| ($mon =~ /^\d\d?$/ && $mon >= 1 && $mon <= 12 && int($mon))|| return;unless (defined$yr){my$cur_mon;($cur_mon,$yr)=(localtime)[4,5];$yr += 1900;$cur_mon++;$yr-- if$mon > $cur_mon}elsif (length($yr)< 3){my$cur_yr=(localtime)[5]+ 1900;my$m=$cur_yr % 100;my$tmp=$yr;$yr += $cur_yr - $m;$m -= $tmp;$yr += ($m > 0)? 100 : -100 if abs($m)> 50}$hr=0 unless defined($hr);$min=0 unless defined($min);$sec=0 unless defined($sec);if ($ampm){$ampm=uc$ampm;$hr=0 if$hr==12 && $ampm eq 'AM';$hr += 12 if$ampm eq 'PM' && $hr!=12}return($yr,$mon,$day,$hr,$min,$sec,$tz)if wantarray;if (defined$tz){$tz="Z" if$tz =~ /^(GMT|UTC?|[-+]?0+)$/}else {$tz=""}return sprintf("%04d-%02d-%02d %02d:%02d:%02d%s",$yr,$mon,$day,$hr,$min,$sec,$tz)}sub time2iso (;$) {my$time=shift;$time=time unless defined$time;my($sec,$min,$hour,$mday,$mon,$year)=localtime($time);sprintf("%04d-%02d-%02d %02d:%02d:%02d",$year+1900,$mon+1,$mday,$hour,$min,$sec)}sub time2isoz (;$) {my$time=shift;$time=time unless defined$time;my($sec,$min,$hour,$mday,$mon,$year)=gmtime($time);sprintf("%04d-%02d-%02d %02d:%02d:%02dZ",$year+1900,$mon+1,$mday,$hour,$min,$sec)}1;
HTTP_DATE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use strict;
use warnings;
use App::tmclean;
App::tmclean->new_with_options(@ARGV)->run;

__END__

=encoding utf-8

=head1 NAME

tmclean - cleanup TimeMachine

=head1 SYNOPSIS

    % tmclean [--dry-run] [--days=300/--before=2018/01/01]

=head2 Options

=over

=item --dry-run

=item --days

Delete backups that before the specified number of days (default: 366)

=item --before

Delete backups before the specified date

=back

=head1 DESCRIPTION

tmclean is command line utility for cleanup TimeMachine.

=head1 INSTALLATION

    % cpanm App::tmclean

or you can get single packed executable file.

    % curl -L https://raw.githubusercontent.com/Songmu/App-tmclean/master/tmclean > /usr/local/bin/tmclean; chmod +x /usr/local/bin/tmclean

=head1 LICENSE

Copyright (C) Songmu.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=head1 AUTHOR

Songmu E<lt>y.songmu@gmail.comE<gt>

=cut

