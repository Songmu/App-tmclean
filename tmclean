#!/usr/bin/env perl
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Algorithm/Diff.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ALGORITHM_DIFF';
  package Algorithm::Diff;use strict;use integer;use vars qw($VERSION @EXPORT_OK);$VERSION=1.19_03;require Exporter;*import=\&Exporter::import;@EXPORT_OK=qw(prepare LCS LCSidx LCS_length diff sdiff compact_diff traverse_sequences traverse_balanced);sub _withPositionsOfInInterval {my$aCollection=shift;my$start=shift;my$end=shift;my$keyGen=shift;my%d;my$index;for ($index=$start ;$index <= $end ;$index++ ){my$element=$aCollection->[$index];my$key=&$keyGen($element,@_);if (exists($d{$key})){unshift (@{$d{$key}},$index)}else {$d{$key}=[$index]}}return wantarray ? %d : \%d}sub _replaceNextLargerWith {my ($array,$aValue,$high)=@_;$high ||= $#$array;if ($high==-1 || $aValue > $array->[-1]){push (@$array,$aValue);return$high + 1}my$low=0;my$index;my$found;while ($low <= $high){$index=($high + $low)/ 2;$found=$array->[$index];if ($aValue==$found){return undef}elsif ($aValue > $found){$low=$index + 1}else {$high=$index - 1}}$array->[$low]=$aValue;return$low}sub _longestCommonSubsequence {my$a=shift;my$b=shift;my$counting=shift;my$keyGen=shift;my$compare;if (ref($a)eq 'HASH'){my$tmp=$b;$b=$a;$a=$tmp}if (!ref($a)||!ref($b)){my@callerInfo=caller(1);die 'error: must pass array or hash references to ' .$callerInfo[3]}if (!defined($keyGen)){$keyGen=sub {$_[0]};$compare=sub {my ($a,$b)=@_;$a eq $b}}else {$compare=sub {my$a=shift;my$b=shift;&$keyGen($a,@_)eq &$keyGen($b,@_)}}my ($aStart,$aFinish,$matchVector)=(0,$#$a,[]);my ($prunedCount,$bMatches)=(0,{});if (ref($b)eq 'HASH'){$bMatches=$b}else {my ($bStart,$bFinish)=(0,$#$b);while ($aStart <= $aFinish and $bStart <= $bFinish and &$compare($a->[$aStart],$b->[$bStart],@_)){$matchVector->[$aStart++ ]=$bStart++;$prunedCount++}while ($aStart <= $aFinish and $bStart <= $bFinish and &$compare($a->[$aFinish],$b->[$bFinish],@_)){$matchVector->[$aFinish-- ]=$bFinish--;$prunedCount++}$bMatches=_withPositionsOfInInterval($b,$bStart,$bFinish,$keyGen,@_)}my$thresh=[];my$links=[];my ($i,$ai,$j,$k);for ($i=$aStart ;$i <= $aFinish ;$i++ ){$ai=&$keyGen($a->[$i],@_);if (exists($bMatches->{$ai})){$k=0;for$j (@{$bMatches->{$ai}}){if ($k and $thresh->[$k]> $j and $thresh->[$k - 1 ]< $j){$thresh->[$k]=$j}else {$k=_replaceNextLargerWith($thresh,$j,$k)}if (defined($k)){$links->[$k]=[($k ? $links->[$k - 1 ]: undef),$i,$j ]}}}}if (@$thresh){return$prunedCount + @$thresh if$counting;for (my$link=$links->[$#$thresh];$link ;$link=$link->[0]){$matchVector->[$link->[1]]=$link->[2]}}elsif ($counting){return$prunedCount}return wantarray ? @$matchVector : $matchVector}sub traverse_sequences {my$a=shift;my$b=shift;my$callbacks=shift || {};my$keyGen=shift;my$matchCallback=$callbacks->{'MATCH'}|| sub {};my$discardACallback=$callbacks->{'DISCARD_A'}|| sub {};my$finishedACallback=$callbacks->{'A_FINISHED'};my$discardBCallback=$callbacks->{'DISCARD_B'}|| sub {};my$finishedBCallback=$callbacks->{'B_FINISHED'};my$matchVector=_longestCommonSubsequence($a,$b,0,$keyGen,@_);my$lastA=$#$a;my$lastB=$#$b;my$bi=0;my$ai;for ($ai=0 ;$ai <= $#$matchVector ;$ai++ ){my$bLine=$matchVector->[$ai];if (defined($bLine)){&$discardBCallback($ai,$bi++,@_)while$bi < $bLine;&$matchCallback($ai,$bi++,@_)}else {&$discardACallback($ai,$bi,@_)}}while ($ai <= $lastA or $bi <= $lastB){if ($ai==$lastA + 1 and $bi <= $lastB){if (defined($finishedACallback)){&$finishedACallback($lastA,@_);$finishedACallback=undef}else {&$discardBCallback($ai,$bi++,@_)while$bi <= $lastB}}if ($bi==$lastB + 1 and $ai <= $lastA){if (defined($finishedBCallback)){&$finishedBCallback($lastB,@_);$finishedBCallback=undef}else {&$discardACallback($ai++,$bi,@_)while$ai <= $lastA}}&$discardACallback($ai++,$bi,@_)if$ai <= $lastA;&$discardBCallback($ai,$bi++,@_)if$bi <= $lastB}return 1}sub traverse_balanced {my$a=shift;my$b=shift;my$callbacks=shift || {};my$keyGen=shift;my$matchCallback=$callbacks->{'MATCH'}|| sub {};my$discardACallback=$callbacks->{'DISCARD_A'}|| sub {};my$discardBCallback=$callbacks->{'DISCARD_B'}|| sub {};my$changeCallback=$callbacks->{'CHANGE'};my$matchVector=_longestCommonSubsequence($a,$b,0,$keyGen,@_);my$lastA=$#$a;my$lastB=$#$b;my$bi=0;my$ai=0;my$ma=-1;my$mb;while (1){do {$ma++}while($ma <= $#$matchVector &&!defined$matchVector->[$ma]);last if$ma > $#$matchVector;$mb=$matchVector->[$ma];while ($ai < $ma || $bi < $mb){if ($ai < $ma && $bi < $mb){if (defined$changeCallback){&$changeCallback($ai++,$bi++,@_)}else {&$discardACallback($ai++,$bi,@_);&$discardBCallback($ai,$bi++,@_)}}elsif ($ai < $ma){&$discardACallback($ai++,$bi,@_)}else {&$discardBCallback($ai,$bi++,@_)}}&$matchCallback($ai++,$bi++,@_)}while ($ai <= $lastA || $bi <= $lastB){if ($ai <= $lastA && $bi <= $lastB){if (defined$changeCallback){&$changeCallback($ai++,$bi++,@_)}else {&$discardACallback($ai++,$bi,@_);&$discardBCallback($ai,$bi++,@_)}}elsif ($ai <= $lastA){&$discardACallback($ai++,$bi,@_)}else {&$discardBCallback($ai,$bi++,@_)}}return 1}sub prepare {my$a=shift;my$keyGen=shift;$keyGen=sub {$_[0]}unless defined($keyGen);return scalar _withPositionsOfInInterval($a,0,$#$a,$keyGen,@_)}sub LCS {my$a=shift;my$b=shift;my$matchVector=_longestCommonSubsequence($a,$b,0,@_);my@retval;my$i;for ($i=0 ;$i <= $#$matchVector ;$i++ ){if (defined($matchVector->[$i])){push (@retval,$a->[$i])}}return wantarray ? @retval : \@retval}sub LCS_length {my$a=shift;my$b=shift;return _longestCommonSubsequence($a,$b,1,@_)}sub LCSidx {my$a=shift @_;my$b=shift @_;my$match=_longestCommonSubsequence($a,$b,0,@_);my@am=grep defined$match->[$_],0..$#$match;my@bm=@{$match}[@am];return \@am,\@bm}sub compact_diff {my$a=shift @_;my$b=shift @_;my($am,$bm)=LCSidx($a,$b,@_);my@cdiff;my($ai,$bi)=(0,0);push@cdiff,$ai,$bi;while(1){while(@$am && $ai==$am->[0]&& $bi==$bm->[0]){shift @$am;shift @$bm;++$ai,++$bi}push@cdiff,$ai,$bi;last if!@$am;$ai=$am->[0];$bi=$bm->[0];push@cdiff,$ai,$bi}push@cdiff,0+@$a,0+@$b if$ai < @$a || $bi < @$b;return wantarray ? @cdiff : \@cdiff}sub diff {my$a=shift;my$b=shift;my$retval=[];my$hunk=[];my$discard=sub {push @$hunk,['-',$_[0],$a->[$_[0]]]};my$add=sub {push @$hunk,['+',$_[1],$b->[$_[1]]]};my$match=sub {push @$retval,$hunk if 0 < @$hunk;$hunk=[]};traverse_sequences($a,$b,{MATCH=>$match,DISCARD_A=>$discard,DISCARD_B=>$add },@_);&$match();return wantarray ? @$retval : $retval}sub sdiff {my$a=shift;my$b=shift;my$retval=[];my$discard=sub {push (@$retval,['-',$a->[$_[0]],"" ])};my$add=sub {push (@$retval,['+',"",$b->[$_[1]]])};my$change=sub {push (@$retval,['c',$a->[$_[0]],$b->[$_[1]]])};my$match=sub {push (@$retval,['u',$a->[$_[0]],$b->[$_[1]]])};traverse_balanced($a,$b,{MATCH=>$match,DISCARD_A=>$discard,DISCARD_B=>$add,CHANGE=>$change,},@_);return wantarray ? @$retval : $retval}my$Root=__PACKAGE__;package Algorithm::Diff::_impl;use strict;sub _Idx() {0}sub _End() {3}sub _Same() {4}sub _Base() {5}sub _Pos() {6}sub _Off() {7}sub _Min() {-2}sub Die {require Carp;Carp::confess(@_)}sub _ChkPos {my($me)=@_;return if$me->[_Pos];my$meth=(caller(1))[3];Die("Called $meth on 'reset' object")}sub _ChkSeq {my($me,$seq)=@_;return$seq + $me->[_Off]if 1==$seq || 2==$seq;my$meth=(caller(1))[3];Die("$meth: Invalid sequence number ($seq); must be 1 or 2")}sub getObjPkg {my($us)=@_;return ref$us if ref$us;return$us ."::_obj"}sub new {my($us,$seq1,$seq2,$opts)=@_;my@args;for($opts->{keyGen}){push@args,$_ if $_}for($opts->{keyGenArgs}){push@args,@$_ if $_}my$cdif=Algorithm::Diff::compact_diff($seq1,$seq2,@args);my$same=1;if(0==$cdif->[2]&& 0==$cdif->[3]){$same=0;splice @$cdif,0,2}my@obj=($cdif,$seq1,$seq2);$obj[_End]=(1+@$cdif)/2;$obj[_Same]=$same;$obj[_Base]=0;my$me=bless \@obj,$us->getObjPkg();$me->Reset(0);return$me}sub Reset {my($me,$pos)=@_;$pos=int($pos || 0);$pos += $me->[_End]if$pos < 0;$pos=0 if$pos < 0 || $me->[_End]<= $pos;$me->[_Pos]=$pos ||!1;$me->[_Off]=2*$pos - 1;return$me}sub Base {my($me,$base)=@_;my$oldBase=$me->[_Base];$me->[_Base]=0+$base if defined$base;return$oldBase}sub Copy {my($me,$pos,$base)=@_;my@obj=@$me;my$you=bless \@obj,ref($me);$you->Reset($pos)if defined$pos;$you->Base($base);return$you}sub Next {my($me,$steps)=@_;$steps=1 if!defined$steps;if($steps){my$pos=$me->[_Pos];my$new=$pos + $steps;$new=0 if$pos && $new < 0;$me->Reset($new)}return$me->[_Pos]}sub Prev {my($me,$steps)=@_;$steps=1 if!defined$steps;my$pos=$me->Next(-$steps);$pos -= $me->[_End]if$pos;return$pos}sub Diff {my($me)=@_;$me->_ChkPos();return 0 if$me->[_Same]==(1 & $me->[_Pos]);my$ret=0;my$off=$me->[_Off];for my$seq (1,2){$ret |= $seq if$me->[_Idx][$off + $seq + _Min ]< $me->[_Idx][$off + $seq ]}return$ret}sub Min {my($me,$seq,$base)=@_;$me->_ChkPos();my$off=$me->_ChkSeq($seq);$base=$me->[_Base]if!defined$base;return$base + $me->[_Idx][$off + _Min ]}sub Max {my($me,$seq,$base)=@_;$me->_ChkPos();my$off=$me->_ChkSeq($seq);$base=$me->[_Base]if!defined$base;return$base + $me->[_Idx][$off ]-1}sub Range {my($me,$seq,$base)=@_;$me->_ChkPos();my$off=$me->_ChkSeq($seq);if(!wantarray){return$me->[_Idx][$off ]- $me->[_Idx][$off + _Min ]}$base=$me->[_Base]if!defined$base;return ($base + $me->[_Idx][$off + _Min ]).. ($base + $me->[_Idx][$off ]- 1)}sub Items {my($me,$seq)=@_;$me->_ChkPos();my$off=$me->_ChkSeq($seq);if(!wantarray){return$me->[_Idx][$off ]- $me->[_Idx][$off + _Min ]}return @{$me->[$seq]}[$me->[_Idx][$off + _Min ].. ($me->[_Idx][$off ]- 1)]}sub Same {my($me)=@_;$me->_ChkPos();return wantarray ? (): 0 if$me->[_Same]!=(1 & $me->[_Pos]);return$me->Items(1)}my%getName;BEGIN {%getName=(same=>\&Same,diff=>\&Diff,base=>\&Base,min=>\&Min,max=>\&Max,range=>\&Range,items=>\&Items,)}sub Get {my$me=shift @_;$me->_ChkPos();my@value;for my$arg (@_){for my$word (split ' ',$arg){my$meth;if($word !~ /^(-?\d+)?([a-zA-Z]+)([12])?$/ || not $meth=$getName{lc $2 }){Die($Root,", Get: Invalid request ($word)")}my($base,$name,$seq)=($1,$2,$3);push@value,scalar(4==length($name)? $meth->($me): $meth->($me,$seq,$base))}}if(wantarray){return@value}elsif(1==@value){return$value[0]}Die(0+@value," values requested from ",$Root,"'s Get in scalar context")}my$Obj=getObjPkg($Root);no strict 'refs';for my$meth (qw(new getObjPkg)){*{$Root."::".$meth}=\&{$meth};*{$Obj ."::".$meth}=\&{$meth}}for my$meth (qw(Next Prev Reset Copy Base Diff Same Items Range Min Max Get _ChkPos _ChkSeq)){*{$Obj."::".$meth}=\&{$meth}}1;
ALGORITHM_DIFF

$fatpacked{"Algorithm/DiffOld.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ALGORITHM_DIFFOLD';
  package Algorithm::DiffOld;use strict;use vars qw($VERSION @EXPORT_OK @ISA @EXPORT);use integer;require Exporter;@ISA=qw(Exporter);@EXPORT=qw();@EXPORT_OK=qw(LCS diff traverse_sequences);$VERSION=1.10;sub _replaceNextLargerWith {my ($array,$aValue,$high)=@_;$high ||= $#$array;if ($high==-1 || $aValue > $array->[-1 ]){push(@$array,$aValue);return$high + 1}my$low=0;my$index;my$found;while ($low <= $high){$index=($high + $low)/ 2;$found=$array->[$index ];if ($aValue==$found){return undef}elsif ($aValue > $found){$low=$index + 1}else {$high=$index - 1}}$array->[$low ]=$aValue;return$low}sub _longestCommonSubsequence {my$a=shift;my$b=shift;my$compare=shift || sub {my$a=shift;my$b=shift;$a eq $b};my$aStart=0;my$aFinish=$#$a;my$bStart=0;my$bFinish=$#$b;my$matchVector=[];while ($aStart <= $aFinish and $bStart <= $bFinish and &$compare($a->[$aStart ],$b->[$bStart ],@_)){$matchVector->[$aStart++ ]=$bStart++}while ($aStart <= $aFinish and $bStart <= $bFinish and &$compare($a->[$aFinish ],$b->[$bFinish ],@_)){$matchVector->[$aFinish-- ]=$bFinish--}my$thresh=[];my$links=[];my ($i,$ai,$j,$k);for ($i=$aStart;$i <= $aFinish;$i++ ){$k=0;for ($j=$bFinish;$j >= $bStart;$j--){next if!&$compare($a->[$i],$b->[$j],@_);if ($k and $thresh->[$k ]> $j and $thresh->[$k - 1 ]< $j){$thresh->[$k ]=$j}else {$k=_replaceNextLargerWith($thresh,$j,$k)}if (defined($k)){$links->[$k ]=[($k ? $links->[$k - 1 ]: undef),$i,$j ]}}}if (@$thresh){for (my$link=$links->[$#$thresh ];$link;$link=$link->[0 ]){$matchVector->[$link->[1 ]]=$link->[2 ]}}return wantarray ? @$matchVector : $matchVector}sub traverse_sequences {my$a=shift;my$b=shift;my$callbacks=shift || {};my$compare=shift;my$matchCallback=$callbacks->{'MATCH'}|| sub {};my$discardACallback=$callbacks->{'DISCARD_A'}|| sub {};my$finishedACallback=$callbacks->{'A_FINISHED'};my$discardBCallback=$callbacks->{'DISCARD_B'}|| sub {};my$finishedBCallback=$callbacks->{'B_FINISHED'};my$matchVector=_longestCommonSubsequence($a,$b,$compare,@_);my$lastA=$#$a;my$lastB=$#$b;my$bi=0;my$ai;for ($ai=0;$ai <= $#$matchVector;$ai++ ){my$bLine=$matchVector->[$ai ];if (defined($bLine)){&$discardBCallback($ai,$bi++,@_)while$bi < $bLine;&$matchCallback($ai,$bi++,@_)}else {&$discardACallback($ai,$bi,@_)}}if (defined($finishedBCallback)&& $ai <= $lastA){&$finishedBCallback($bi,@_)}else {&$discardACallback($ai++,$bi,@_)while ($ai <= $lastA)}if (defined($finishedACallback)&& $bi <= $lastB){&$finishedACallback($ai,@_)}else {&$discardBCallback($ai,$bi++,@_)while ($bi <= $lastB)}return 1}sub LCS {my$a=shift;my$matchVector=_longestCommonSubsequence($a,@_);my@retval;my$i;for ($i=0;$i <= $#$matchVector;$i++ ){if (defined($matchVector->[$i ])){push(@retval,$a->[$i ])}}return wantarray ? @retval : \@retval}sub diff {my$a=shift;my$b=shift;my$retval=[];my$hunk=[];my$discard=sub {push(@$hunk,['-',$_[0 ],$a->[$_[0 ]]])};my$add=sub {push(@$hunk,['+',$_[1 ],$b->[$_[1 ]]])};my$match=sub {push(@$retval,$hunk)if scalar(@$hunk);$hunk=[]};traverse_sequences($a,$b,{MATCH=>$match,DISCARD_A=>$discard,DISCARD_B=>$add },@_);&$match();return wantarray ? @$retval : $retval}1;
ALGORITHM_DIFFOLD

$fatpacked{"Algorithm/cdiff.pl"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ALGORITHM_CDIFF.PL';
  use strict;use Algorithm::Diff qw(diff);use File::stat;use vars qw ($opt_C $opt_c $opt_u $opt_U);use Getopt::Std;my$usage=<< "ENDUSAGE";getopts('U:C:cu')or bag("$usage");bag("$usage")unless@ARGV==2;my ($file1,$file2)=@ARGV;if (defined$opt_C || defined$opt_c){$opt_c="";$opt_u=undef}elsif (defined$opt_U || defined$opt_u){$opt_u="";$opt_c=undef}else {$opt_c=""}my ($char1,$char2);my$Context_Lines;if (defined$opt_c){$Context_Lines=defined$opt_C ? $opt_C : 3;$char1='*' x 3;$char2='-' x 3}elsif (defined$opt_u){$Context_Lines=defined$opt_U ? $opt_U : 3;$char1='-' x 3;$char2='+' x 3}my$File_Length_Difference=0;open (F1,$file1)or bag("Couldn't open $file1: $!");open (F2,$file2)or bag("Couldn't open $file2: $!");my (@f1,@f2);chomp(@f1=<F1>);close F1;chomp(@f2=<F2>);close F2;my$diffs=diff(\@f1,\@f2);exit 0 unless @$diffs;my$st=stat($file1);print "$char1 $file1\t",scalar localtime($st->mtime),"\n";$st=stat($file2);print "$char2 $file2\t",scalar localtime($st->mtime),"\n";my ($hunk,$oldhunk);for my$piece (@$diffs){$hunk=new Hunk ($piece,$Context_Lines);next unless$oldhunk;if ($hunk->does_overlap($oldhunk)){$hunk->prepend_hunk($oldhunk)}else {$oldhunk->output_diff(\@f1,\@f2)}}continue {$oldhunk=$hunk}$oldhunk->output_diff(\@f1,\@f2);exit 1;sub bag {my$msg=shift;$msg .= "\n";warn$msg;exit 2}{package Hunk;sub new {my ($class,$piece,$context_items)=@_;my$block=new Block ($piece);my$before_diff=$File_Length_Difference;my$after_diff=$before_diff + $block->{"length_diff"};$File_Length_Difference += $block->{"length_diff"};my@remove_array=$block->remove;my@insert_array=$block->insert;my ($a1,$a2,$b1,$b2,$start1,$start2,$end1,$end2);$a1=@remove_array ? $remove_array[0 ]->{"item_no"}: -1;$a2=@remove_array ? $remove_array[-1]->{"item_no"}: -1;$b1=@insert_array ? $insert_array[0 ]->{"item_no"}: -1;$b2=@insert_array ? $insert_array[-1]->{"item_no"}: -1;$start1=$a1==-1 ? $b1 - $before_diff : $a1;$end1=$a2==-1 ? $b2 - $after_diff : $a2;$start2=$b1==-1 ? $a1 + $before_diff : $b1;$end2=$b2==-1 ? $a2 + $after_diff : $b2;my$hunk={"start1"=>$start1,"start2"=>$start2,"end1"=>$end1,"end2"=>$end2,"blocks"=>[$block],};bless$hunk,$class;$hunk->flag_context($context_items);return$hunk}sub flag_context {my ($hunk,$context_items)=@_;return unless$context_items;my$start1=$hunk->{"start1"};my$num_added=$context_items > $start1 ? $start1 : $context_items;$hunk->{"start1"}-= $num_added;$hunk->{"start2"}-= $num_added;my$end1=$hunk->{"end1"};$num_added=($end1+$context_items > $#f1)? $#f1 - $end1 : $context_items;$hunk->{"end1"}+= $num_added;$hunk->{"end2"}+= $num_added}sub does_overlap {my ($hunk,$oldhunk)=@_;return "" unless$oldhunk;return ($hunk->{"start1"}- $oldhunk->{"end1"}<= 1 || $hunk->{"start2"}- $oldhunk->{"end2"}<= 1)}sub prepend_hunk {my ($hunk,$oldhunk)=@_;$hunk->{"start1"}=$oldhunk->{"start1"};$hunk->{"start2"}=$oldhunk->{"start2"};unshift (@{$hunk->{"blocks"}},@{$oldhunk->{"blocks"}})}sub output_diff {if (defined$main::opt_u){&output_unified_diff(@_)}elsif (defined$main::opt_c){&output_context_diff(@_)}else {die "unknown diff"}}sub output_unified_diff {my ($hunk,$fileref1,$fileref2)=@_;my@blocklist;my$range1=$hunk->unified_range(1);my$range2=$hunk->unified_range(2);print "@@ -$range1 +$range2 @@\n";my$low=$hunk->{"start1"};my$hi=$hunk->{"end1"};my ($num_added,$num_removed)=(0,0);my@outlist=@$fileref1[$low..$hi];map {s/^/ /}@outlist;for my$block (@{$hunk->{"blocks"}}){for my$item ($block->remove){my$op=$item->{"sign"};my$offset=$item->{"item_no"}- $low + $num_added;$outlist[$offset]=~ s/^ /$op/;$num_removed++}for my$item ($block->insert){my$op=$item->{"sign"};my$i=$item->{"item_no"};my$offset=$i - $hunk->{"start2"}+ $num_removed;splice(@outlist,$offset,0,"$op$$fileref2[$i]");$num_added++}}map {s/$/\n/}@outlist;print@outlist}sub output_context_diff {my ($hunk,$fileref1,$fileref2)=@_;my@blocklist;print "***************\n";my$range1=$hunk->context_range(1);my$range2=$hunk->context_range(2);print "*** $range1 ****\n";my$low=$hunk->{"start1"};my$hi=$hunk->{"end1"};if (@blocklist=grep {$_->remove}@{$hunk->{"blocks"}}){my@outlist=@$fileref1[$low..$hi];map {s/^/  /}@outlist;for my$block (@blocklist){my$op=$block->op;for my$item ($block->remove){$outlist[$item->{"item_no"}- $low]=~ s/^ /$op/}}map {s/$/\n/}@outlist;print@outlist}print "--- $range2 ----\n";$low=$hunk->{"start2"};$hi=$hunk->{"end2"};if (@blocklist=grep {$_->insert}@{$hunk->{"blocks"}}){my@outlist=@$fileref2[$low..$hi];map {s/^/  /}@outlist;for my$block (@blocklist){my$op=$block->op;for my$item ($block->insert){$outlist[$item->{"item_no"}- $low]=~ s/^ /$op/}}map {s/$/\n/}@outlist;print@outlist}}sub context_range {my ($hunk,$flag)=@_;my ($start,$end)=($hunk->{"start$flag"},$hunk->{"end$flag"});$start++;$end++;my$range=($start < $end)? "$start,$end" : $end;return$range}sub unified_range {my ($hunk,$flag)=@_;my ($start,$end)=($hunk->{"start$flag"},$hunk->{"end$flag"});$start++;$end++;my$length=$end - $start + 1;my$first=$length < 2 ? $end : $start;my$range=$length==1 ? $first : "$first,$length";return$range}}{package Block;sub new {my ($class,$chunk)=@_;my@changes=();for my$item (@$chunk){my ($sign,$item_no,$text)=@$item;my$hashref={"sign"=>$sign,"item_no"=>$item_no};push@changes,$hashref}my$block={"changes"=>\@changes };bless$block,$class;$block->{"length_diff"}=$block->insert - $block->remove;return$block}sub op {my$block=shift;my$insert=$block->insert;my$remove=$block->remove;$remove && $insert and return '!';$remove and return '-';$insert and return '+';warn "unknown block type";return '^'}sub remove {return grep {$_->{"sign"}eq '-'}@{shift->{"changes"}}}sub insert {return grep {$_->{"sign"}eq '+'}@{shift->{"changes"}}}}
  Usage: $0 [{-c | -u}] [{-C | -U} lines] oldfile newfile
      -c will do a context diff with 3 lines of context
      -C will do a context diff with 'lines' lines of context
      -u will do a unified diff with 3 lines of context
      -U will do a unified diff with 'lines' lines of context
  ENDUSAGE
ALGORITHM_CDIFF.PL

$fatpacked{"Algorithm/diff.pl"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ALGORITHM_DIFF.PL';
  use Algorithm::Diff qw(diff);bag("Usage: $0 oldfile newfile")unless@ARGV==2;my ($file1,$file2)=@ARGV;-T $file1 or bag("$file1: binary");-T $file2 or bag("$file2: binary");open (F1,$file1)or bag("Couldn't open $file1: $!");open (F2,$file2)or bag("Couldn't open $file2: $!");chomp(@f1=<F1>);close F1;chomp(@f2=<F2>);close F2;$diffs=diff(\@f1,\@f2);exit 0 unless @$diffs;for$chunk (@$diffs){for$line (@$chunk){my ($sign,$lineno,$text)=@$line;printf "%4d$sign %s\n",$lineno+1,$text}print "--------\n"}exit 1;sub bag {my$msg=shift;$msg .= "\n";warn$msg;exit 2}
ALGORITHM_DIFF.PL

$fatpacked{"Algorithm/diffnew.pl"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ALGORITHM_DIFFNEW.PL';
  use strict;use Algorithm::Diff qw(diff);my$File_Length_Difference=0;my@Ed_Hunks=();my$usage=<< "ENDUSAGE";my$Context_Lines=0;my$Diff_Type="OLD";my ($opt_c,$opt_u,$opt_e,$opt_f,$opt_q,$opt_i,$opt_w);my$compareRoutineRef=undef;while ($ARGV[0]=~ /^-/){my$opt=shift;last if$opt eq '--';if ($opt =~ /^-C(.*)/){$Context_Lines=$1 || shift;$opt_c=1;$Diff_Type="CONTEXT"}elsif ($opt =~ /^-c$/){$Context_Lines=3;$opt_c=1;$Diff_Type="CONTEXT"}elsif ($opt =~ /^-e$/){$opt_e=1;$Diff_Type="ED"}elsif ($opt =~ /^-f$/){$opt_f=1;$Diff_Type="REVERSE_ED"}elsif ($opt =~ /^-U(.*)$/){$Context_Lines=$1 || shift;$opt_u=1;$Diff_Type="UNIFIED"}elsif ($opt =~ /^-u$/){$Context_Lines=3;$opt_u=1;$Diff_Type="UNIFIED"}elsif ($opt =~ /^-q$/){$Context_Lines=0;$opt_q=1;$opt_e=1;$Diff_Type="ED"}elsif ($opt =~ /^-i$/){$opt_i=1;$compareRoutineRef=\&compareRoutine}elsif ($opt =~ /^-w$/){$opt_w=1;$compareRoutineRef=\&compareRoutine}else {$opt =~ s/^-//;bag("Illegal option -- $opt")}}if ($opt_q and grep($_,($opt_c,$opt_f,$opt_u))> 1){bag("Combining -q with other options is nonsensical")}if (grep($_,($opt_c,$opt_e,$opt_f,$opt_u))> 1){bag("Only one of -c, -u, -f, -e are allowed")}bag($usage)unless@ARGV==2;my ($file1,$file2)=@ARGV;my ($char1,$char2);if ($Diff_Type eq "CONTEXT"){$char1='*' x 3;$char2='-' x 3}elsif ($Diff_Type eq "UNIFIED"){$char1='-' x 3;$char2='+' x 3}open (F1,$file1)or bag("Couldn't open $file1: $!");open (F2,$file2)or bag("Couldn't open $file2: $!");my (@f1,@f2);chomp(@f1=<F1>);close F1;chomp(@f2=<F2>);close F2;my$diffs=diff(\@f1,\@f2,$compareRoutineRef);exit 0 unless @$diffs;if ($opt_q and @$diffs){print "Files $file1 and $file2 differ\n";exit 1}if ($Diff_Type =~ /UNIFIED|CONTEXT/){my@st=stat($file1);my$MTIME=9;print "$char1 $file1\t",scalar localtime($st[$MTIME]),"\n";@st=stat($file2);print "$char2 $file2\t",scalar localtime($st[$MTIME]),"\n"}my ($hunk,$oldhunk);for my$piece (@$diffs){$hunk=new Hunk ($piece,$Context_Lines);next unless$oldhunk;if ($Context_Lines && $hunk->does_overlap($oldhunk)){$hunk->prepend_hunk($oldhunk)}else {$oldhunk->output_diff(\@f1,\@f2,$Diff_Type)}}continue {$oldhunk=$hunk}$oldhunk->output_diff(\@f1,\@f2,$Diff_Type);map {$_->output_ed_diff(\@f1,\@f2,$Diff_Type)}@Ed_Hunks if@Ed_Hunks;exit 1;sub bag {my$msg=shift;$msg .= "\n";warn$msg;exit 2}sub compareRoutine {my$line=shift;$line =~ s/[ \t\r\n]+//g if ($opt_w);$line=uc($line)if ($opt_i);return$line}{package Hunk;sub new {my ($class,$piece,$context_items)=@_;my$block=new Block ($piece);my$before_diff=$File_Length_Difference;my$after_diff=$before_diff + $block->{"length_diff"};$File_Length_Difference += $block->{"length_diff"};my@remove_array=$block->remove;my@insert_array=$block->insert;my ($a1,$a2,$b1,$b2,$start1,$start2,$end1,$end2);$a1=@remove_array ? $remove_array[0 ]->{"item_no"}: -1;$a2=@remove_array ? $remove_array[-1]->{"item_no"}: -1;$b1=@insert_array ? $insert_array[0 ]->{"item_no"}: -1;$b2=@insert_array ? $insert_array[-1]->{"item_no"}: -1;$start1=$a1==-1 ? $b1 - $before_diff : $a1;$end1=$a2==-1 ? $b2 - $after_diff : $a2;$start2=$b1==-1 ? $a1 + $before_diff : $b1;$end2=$b2==-1 ? $a2 + $after_diff : $b2;my$hunk={"start1"=>$start1,"start2"=>$start2,"end1"=>$end1,"end2"=>$end2,"blocks"=>[$block],};bless$hunk,$class;$hunk->flag_context($context_items);return$hunk}sub flag_context {my ($hunk,$context_items)=@_;return unless$context_items;my$start1=$hunk->{"start1"};my$num_added=$context_items > $start1 ? $start1 : $context_items;$hunk->{"start1"}-= $num_added;$hunk->{"start2"}-= $num_added;my$end1=$hunk->{"end1"};$num_added=($end1+$context_items > $#f1)? $#f1 - $end1 : $context_items;$hunk->{"end1"}+= $num_added;$hunk->{"end2"}+= $num_added}sub does_overlap {my ($hunk,$oldhunk)=@_;return "" unless$oldhunk;return ($hunk->{"start1"}- $oldhunk->{"end1"}<= 1 || $hunk->{"start2"}- $oldhunk->{"end2"}<= 1)}sub prepend_hunk {my ($hunk,$oldhunk)=@_;$hunk->{"start1"}=$oldhunk->{"start1"};$hunk->{"start2"}=$oldhunk->{"start2"};unshift (@{$hunk->{"blocks"}},@{$oldhunk->{"blocks"}})}sub output_diff {my$diff_type=$_[-1];my%funchash=("OLD"=>\&output_old_diff,"CONTEXT"=>\&output_context_diff,"ED"=>\&store_ed_diff,"REVERSE_ED"=>\&output_ed_diff,"UNIFIED"=>\&output_unified_diff,);if (exists$funchash{$diff_type}){&{$funchash{$diff_type}}(@_)}else {die "unknown diff type $diff_type"}}sub output_old_diff {my ($hunk,$fileref1,$fileref2)=@_;my%op_hash=('+'=>'a','-'=>'d','!'=>'c');my@blocklist=@{$hunk->{"blocks"}};warn ("Expecting one block in an old diff hunk!")if scalar@blocklist!=1;my$block=$blocklist[0];my$op=$block->op;my$range1=$hunk->context_range(1);my$range2=$hunk->context_range(2);my$action=$op_hash{$op}|| warn "unknown op $op";print "$range1$action$range2\n";if ($block->remove){my@outlist=@$fileref1[$hunk->{"start1"}..$hunk->{"end1"}];map {$_="< $_\n"}@outlist;print@outlist}print "---\n" if$op eq '!';if ($block->insert){my@outlist=@$fileref2[$hunk->{"start2"}..$hunk->{"end2"}];map {$_="> $_\n"}@outlist;print@outlist}}sub output_unified_diff {my ($hunk,$fileref1,$fileref2)=@_;my@blocklist;my$range1=$hunk->unified_range(1);my$range2=$hunk->unified_range(2);print "@@ -$range1 +$range2 @@\n";my$low=$hunk->{"start1"};my$hi=$hunk->{"end1"};my ($num_added,$num_removed)=(0,0);my@outlist=@$fileref1[$low..$hi];map {s/^/ /}@outlist;for my$block (@{$hunk->{"blocks"}}){for my$item ($block->remove){my$op=$item->{"sign"};my$offset=$item->{"item_no"}- $low + $num_added;$outlist[$offset]=~ s/^ /$op/;$num_removed++}for my$item ($block->insert){my$op=$item->{"sign"};my$i=$item->{"item_no"};my$offset=$i - $hunk->{"start2"}+ $num_removed;splice(@outlist,$offset,0,"$op$$fileref2[$i]");$num_added++}}map {s/$/\n/}@outlist;print@outlist}sub output_context_diff {my ($hunk,$fileref1,$fileref2)=@_;my@blocklist;print "***************\n";my$range1=$hunk->context_range(1);my$range2=$hunk->context_range(2);print "*** $range1 ****\n";my$low=$hunk->{"start1"};my$hi=$hunk->{"end1"};if (@blocklist=grep {$_->remove}@{$hunk->{"blocks"}}){my@outlist=@$fileref1[$low..$hi];map {s/^/  /}@outlist;for my$block (@blocklist){my$op=$block->op;for my$item ($block->remove){$outlist[$item->{"item_no"}- $low]=~ s/^ /$op/}}map {s/$/\n/}@outlist;print@outlist}print "--- $range2 ----\n";$low=$hunk->{"start2"};$hi=$hunk->{"end2"};if (@blocklist=grep {$_->insert}@{$hunk->{"blocks"}}){my@outlist=@$fileref2[$low..$hi];map {s/^/  /}@outlist;for my$block (@blocklist){my$op=$block->op;for my$item ($block->insert){$outlist[$item->{"item_no"}- $low]=~ s/^ /$op/}}map {s/$/\n/}@outlist;print@outlist}}sub store_ed_diff {my$hunk=shift;unshift@Ed_Hunks,$hunk}sub output_ed_diff {my$diff_type=$_[-1];my ($hunk,$fileref1,$fileref2)=@_;my%op_hash=('+'=>'a','-'=>'d','!'=>'c');my@blocklist=@{$hunk->{"blocks"}};warn ("Expecting one block in an ed diff hunk!")if scalar@blocklist!=1;my$block=$blocklist[0];my$op=$block->op;my$range1=$hunk->context_range(1);$range1 =~ s/,/ / if$diff_type eq "REVERSE_ED";my$action=$op_hash{$op}|| warn "unknown op $op";print ($diff_type eq "ED" ? "$range1$action\n" : "$action$range1\n");if ($block->insert){my@outlist=@$fileref2[$hunk->{"start2"}..$hunk->{"end2"}];map {s/$/\n/}@outlist;print@outlist;print ".\n"}}sub context_range {my ($hunk,$flag)=@_;my ($start,$end)=($hunk->{"start$flag"},$hunk->{"end$flag"});$start++;$end++;my$range=($start < $end)? "$start,$end" : $end;return$range}sub unified_range {my ($hunk,$flag)=@_;my ($start,$end)=($hunk->{"start$flag"},$hunk->{"end$flag"});$start++;$end++;my$length=$end - $start + 1;my$first=$length < 2 ? $end : $start;my$range=$length==1 ? $first : "$first,$length";return$range}}{package Block;sub new {my ($class,$chunk)=@_;my@changes=();for my$item (@$chunk){my ($sign,$item_no,$text)=@$item;my$hashref={"sign"=>$sign,"item_no"=>$item_no};push@changes,$hashref}my$block={"changes"=>\@changes };bless$block,$class;$block->{"length_diff"}=$block->insert - $block->remove;return$block}sub op {my$block=shift;my$insert=$block->insert;my$remove=$block->remove;$remove && $insert and return '!';$remove and return '-';$insert and return '+';warn "unknown block type";return '^'}sub remove {return grep {$_->{"sign"}eq '-'}@{shift->{"changes"}}}sub insert {return grep {$_->{"sign"}eq '+'}@{shift->{"changes"}}}}
  Usage: $0 [{-c | -C lines -e | -f | -u | -U lines |-q | -i | -w}] oldfile newfile
      -c do a context diff with 3 lines of context
      -C do a context diff with 'lines' lines of context (implies -c)
      -e create a script for the ed editor to change oldfile to newfile
      -f like -e but in reverse order
      -u do a unified diff with 3 lines of context
      -U do a unified diff with 'lines' lines of context (implies -u)
      -q report only whether or not the files differ
      -i ignore differences in Upper/lower-case
      -w ignore differences in white-space (space and TAB characters)
  
  By default it will do an "old-style" diff, with output like UNIX diff
  ENDUSAGE
ALGORITHM_DIFFNEW.PL

$fatpacked{"Algorithm/htmldiff.pl"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ALGORITHM_HTMLDIFF.PL';
  use strict;use CGI qw(:standard :html3);use Algorithm::Diff 'traverse_sequences';use Text::Tabs;my (@a,@b);sub preprocess {my$arrayRef=shift;chomp(@$arrayRef);@$arrayRef=expand(@$arrayRef)}sub match {my ($ia,$ib)=@_;print pre($a[$ia]),"\n"}sub only_a {my ($ia,$ib)=@_;print pre({-class=>'onlyA' },$a[$ia]),"\n"}sub only_b {my ($ia,$ib)=@_;print pre({-class=>'onlyB' },$b[$ib]),"\n"}print "usage: $0 file1 file2 > diff.html\n" if@ARGV!=2;$tabstop=4;open FH,$ARGV[0];@a=<FH>;close FH;open FH,$ARGV[1];@b=<FH>;close FH;preprocess(\@a);preprocess(\@b);my$style=<<EOS;print start_html({-title=>"$ARGV[0] vs. $ARGV[1]",-style=>{-code=>$style }}),h1({-style=>'margin-left: 24pt' },span({-style=>'color: red' },$ARGV[0]),span(" <i>vs.</i> "),span({-style=>'color: blue' },$ARGV[1])),"\n";traverse_sequences(\@a,\@b,{MATCH=>\&match,DISCARD_A=>\&only_a,DISCARD_B=>\&only_b,});print end_html();
  	PRE {
  		margin-left: 24pt; 
  		font-size: 12pt;
  	    font-family: Courier, monospaced;
  		white-space: pre
      }
  	PRE.onlyA { color: red }
  	PRE.onlyB { color: blue }
  EOS
ALGORITHM_HTMLDIFF.PL

$fatpacked{"App/tmclean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_TMCLEAN';
  package App::tmclean;use 5.010;use warnings;use Getopt::Long qw/GetOptions :config posix_default no_ignore_case bundling auto_help/;use Pod::Usage qw/pod2usage/;use Hash::Rename qw/hash_rename/;use Class::Accessor::Lite (new=>1,ro=>[qw/before days dry_run/],);use HTTP::Date qw/str2time/;use Time::Piece ();use Time::Seconds ();our$VERSION="0.01";sub logf {my$msg=shift;$msg=sprintf($msg,@_);my$prefix='[tmclan]' .Time::Piece->localtime->strftime('[%Y-%m-%d %H:%M:%S] ');$msg .= "\n" if$msg !~ /\n$/;print STDERR$prefix .$msg}sub new_with_options {my ($class,@argv)=@_;my ($opt)=$class->parse_options(@argv);$class->new($opt)}sub parse_options {my ($class,@argv)=@_;local@ARGV=@argv;GetOptions(\my%opt,qw/days=i before=s dry-run/)or pod2usage(2);hash_rename%opt,code=>sub {tr/-/_/};return (\%opt,\@ARGV)}sub run {my$self=shift;if (!$self->dry_run && $ENV{USER}ne 'root'){die "tmutil requires root privileges\n"}$self->cmd('tmutil','stopbackup');$self->cmd('tmutil','disable');my@targets=$self->backups2delete;unless (@targets){logf 'no deletion targets found';return 0}my$mount_point=$self->mount_point;logf "following backups to be deleted:\n  %s",join("\n  ",@targets);for my$bak (@targets){$self->cmd('tmutil','delete',$bak)}my$dev_name=dev_name($targets[0]);$self->cmd('hdiutil','detach',$dev_name);my$sparsebundle_path=sprintf '%s/%s.sparsebundle',$mount_point,$self->machine_name;$self->cmd('hdiutil','compact',$sparsebundle_path);$self->cmd('tmutil','enable')}sub backups2delete {my$self=shift;my@backups=`tmutil listbackups`;if ($?!=0){die "failed to execute `tmutil listbackups`: $?\n"}return grep {chomp;my@paths=split m!/!,$_;my$backup_date=Time::Piece->strptime($paths[-1],'%Y-%m-%d-%H%M%S');$self->before_tp > $backup_date}@backups}sub mount_point {my$self=shift;$self->{mount_point}||= sub {my@lines=`tmutil destinationinfo`;if ($?!=0){die "failed to execute `tmutil destinationinfo`: $?\n"}for my$line (@lines){chomp$line;my ($key,$val)=split /\s+:\s+/,$line,2;if ($key eq 'Mount Point'){return$val}}die "no mount points found\n"}->()}sub dev_name {my$path=shift;my@paths=split m!/!,$path;join '/',@paths[0..2]}sub machine_name {my$self=shift;$self->{machine_name}||= do {chomp(my$hostname=`hostname`);if ($?!=0){die "failed to execute `hostname`: $?\n"}$hostname =~ s/\.local$//;$hostname}}sub before_tp {my$self=shift;$self->{before_tp}||= sub {if ($self->before){my$time=str2time$self->before;die "unrecognized date format @{[$self->before]}" unless$time;return Time::Piece->localtime($time)}my$days=$self->days || 366;return Time::Piece->localtime()- Time::Seconds::ONE_DAY()* $days}->()}sub cmd {my ($self,@command)=@_;my$cmd_str=join(' ',@command);logf 'execute%s: `%s`',$self->dry_run ? '(dry-run)' : '',$cmd_str;if (!$self->dry_run){!system(@command)or die "failed to execute command: $cmd_str: $?\n"}}1;
APP_TMCLEAN

$fatpacked{"Capture/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CAPTURE_TINY';
  use 5.006;use strict;use warnings;package Capture::Tiny;our$VERSION='0.48';use Carp ();use Exporter ();use IO::Handle ();use File::Spec ();use File::Temp qw/tempfile tmpnam/;use Scalar::Util qw/reftype blessed/;BEGIN {local $@;eval {require PerlIO;PerlIO->can('get_layers')}or *PerlIO::get_layers=sub {return ()}}my%api=(capture=>[1,1,0,0],capture_stdout=>[1,0,0,0],capture_stderr=>[0,1,0,0],capture_merged=>[1,1,1,0],tee=>[1,1,0,1],tee_stdout=>[1,0,0,1],tee_stderr=>[0,1,0,1],tee_merged=>[1,1,1,1],);for my$sub (keys%api){my$args=join q{, },@{$api{$sub}};eval "sub $sub(&;@) {unshift \@_, $args; goto \\&_capture_tee;}"}our@ISA=qw/Exporter/;our@EXPORT_OK=keys%api;our%EXPORT_TAGS=('all'=>\@EXPORT_OK);my$IS_WIN32=$^O eq 'MSWin32';our$TIMEOUT=30;my@cmd=($^X,'-C0','-e',<<'HERE');sub _relayer {my ($fh,$apply_layers)=@_;binmode($fh,":raw");while (1 < (my$layers=()=PerlIO::get_layers($fh,output=>1))){binmode($fh,":pop")}my@to_apply=@$apply_layers;shift@to_apply;binmode($fh,":" .join(":",@to_apply))}sub _name {my$glob=shift;no strict 'refs';return *{$glob}{NAME}}sub _open {open $_[0],$_[1]or Carp::confess "Error from open(" .join(q{, },@_)."): $!"}sub _close {close $_[0]or Carp::confess "Error from close(" .join(q{, },@_)."): $!"}my%dup;my%proxy_count;sub _proxy_std {my%proxies;if (!defined fileno STDIN){$proxy_count{stdin}++;if (defined$dup{stdin}){_open \*STDIN,"<&=" .fileno($dup{stdin})}else {_open \*STDIN,"<" .File::Spec->devnull;_open$dup{stdin}=IO::Handle->new,"<&=STDIN"}$proxies{stdin}=\*STDIN;binmode(STDIN,':utf8')if $] >= 5.008}if (!defined fileno STDOUT){$proxy_count{stdout}++;if (defined$dup{stdout}){_open \*STDOUT,">&=" .fileno($dup{stdout})}else {_open \*STDOUT,">" .File::Spec->devnull;_open$dup{stdout}=IO::Handle->new,">&=STDOUT"}$proxies{stdout}=\*STDOUT;binmode(STDOUT,':utf8')if $] >= 5.008}if (!defined fileno STDERR){$proxy_count{stderr}++;if (defined$dup{stderr}){_open \*STDERR,">&=" .fileno($dup{stderr})}else {_open \*STDERR,">" .File::Spec->devnull;_open$dup{stderr}=IO::Handle->new,">&=STDERR"}$proxies{stderr}=\*STDERR;binmode(STDERR,':utf8')if $] >= 5.008}return%proxies}sub _unproxy {my (%proxies)=@_;for my$p (keys%proxies){$proxy_count{$p}--;if (!$proxy_count{$p}){_close$proxies{$p};_close$dup{$p}unless $] < 5.008;delete$dup{$p}}}}sub _copy_std {my%handles;for my$h (qw/stdout stderr stdin/){next if$h eq 'stdin' &&!$IS_WIN32;my$redir=$h eq 'stdin' ? "<&" : ">&";_open$handles{$h}=IO::Handle->new(),$redir .uc($h)}return \%handles}sub _open_std {my ($handles)=@_;_open \*STDIN,"<&" .fileno$handles->{stdin}if defined$handles->{stdin};_open \*STDOUT,">&" .fileno$handles->{stdout}if defined$handles->{stdout};_open \*STDERR,">&" .fileno$handles->{stderr}if defined$handles->{stderr}}sub _start_tee {my ($which,$stash)=@_;$stash->{$_}{$which}=IO::Handle->new for qw/tee reader/;pipe$stash->{reader}{$which},$stash->{tee}{$which};select((select($stash->{tee}{$which}),$|=1)[0]);$stash->{new}{$which}=$stash->{tee}{$which};$stash->{child}{$which}={stdin=>$stash->{reader}{$which},stdout=>$stash->{old}{$which},stderr=>$stash->{capture}{$which},};$stash->{flag_files}{$which}=scalar(tmpnam()).$$;if ($IS_WIN32){my$old_eval_err=$@;undef $@;eval "use Win32API::File qw/GetOsFHandle SetHandleInformation fileLastError HANDLE_FLAG_INHERIT INVALID_HANDLE_VALUE/ ";my$os_fhandle=GetOsFHandle($stash->{tee}{$which});my$result=SetHandleInformation($os_fhandle,HANDLE_FLAG_INHERIT(),0);_open_std($stash->{child}{$which});$stash->{pid}{$which}=system(1,@cmd,$stash->{flag_files}{$which});$@=$old_eval_err}else {_fork_exec($which,$stash)}}sub _fork_exec {my ($which,$stash)=@_;my$pid=fork;if (not defined$pid){Carp::confess "Couldn't fork(): $!"}elsif ($pid==0){untie*STDIN;untie*STDOUT;untie*STDERR;_close$stash->{tee}{$which};_open_std($stash->{child}{$which});exec@cmd,$stash->{flag_files}{$which}}$stash->{pid}{$which}=$pid}my$have_usleep=eval "use Time::HiRes 'usleep'; 1";sub _files_exist {return 1 if @_==grep {-f}@_;Time::HiRes::usleep(1000)if$have_usleep;return 0}sub _wait_for_tees {my ($stash)=@_;my$start=time;my@files=values %{$stash->{flag_files}};my$timeout=defined$ENV{PERL_CAPTURE_TINY_TIMEOUT}? $ENV{PERL_CAPTURE_TINY_TIMEOUT}: $TIMEOUT;1 until _files_exist(@files)|| ($timeout && (time - $start > $timeout));Carp::confess "Timed out waiting for subprocesses to start" if!_files_exist(@files);unlink $_ for@files}sub _kill_tees {my ($stash)=@_;if ($IS_WIN32){close($_)for values %{$stash->{tee}};my$start=time;1 until wait==-1 || (time - $start > 30)}else {_close $_ for values %{$stash->{tee}};waitpid $_,0 for values %{$stash->{pid}}}}sub _slurp {my ($name,$stash)=@_;my ($fh,$pos)=map {$stash->{$_}{$name}}qw/capture pos/;seek($fh,$pos,0)or die "Couldn't seek on capture handle for $name\n";my$text=do {local $/;scalar readline$fh};return defined($text)? $text : ""}sub _capture_tee {my ($do_stdout,$do_stderr,$do_merge,$do_tee,$code,@opts)=@_;my%do=($do_stdout ? (stdout=>1): (),$do_stderr ? (stderr=>1): ());Carp::confess("Custom capture options must be given as key/value pairs\n")unless@opts % 2==0;my$stash={capture=>{@opts }};for (keys %{$stash->{capture}}){my$fh=$stash->{capture}{$_};Carp::confess "Custom handle for $_ must be seekable\n" unless ref($fh)eq 'GLOB' || (blessed($fh)&& $fh->isa("IO::Seekable"))}local*CT_ORIG_STDIN=*STDIN ;local*CT_ORIG_STDOUT=*STDOUT;local*CT_ORIG_STDERR=*STDERR;my%layers=(stdin=>[PerlIO::get_layers(\*STDIN)],stdout=>[PerlIO::get_layers(\*STDOUT,output=>1)],stderr=>[PerlIO::get_layers(\*STDERR,output=>1)],);$layers{stdout}=[PerlIO::get_layers(tied*STDOUT)]if tied(*STDOUT)&& (reftype tied*STDOUT eq 'GLOB');$layers{stderr}=[PerlIO::get_layers(tied*STDERR)]if tied(*STDERR)&& (reftype tied*STDERR eq 'GLOB');my%localize;$localize{stdin}++,local(*STDIN)if grep {$_ eq 'scalar'}@{$layers{stdin}};$localize{stdout}++,local(*STDOUT)if$do_stdout && grep {$_ eq 'scalar'}@{$layers{stdout}};$localize{stderr}++,local(*STDERR)if ($do_stderr || $do_merge)&& grep {$_ eq 'scalar'}@{$layers{stderr}};$localize{stdin}++,local(*STDIN),_open(\*STDIN,"<&=0")if tied*STDIN && $] >= 5.008;$localize{stdout}++,local(*STDOUT),_open(\*STDOUT,">&=1")if$do_stdout && tied*STDOUT && $] >= 5.008;$localize{stderr}++,local(*STDERR),_open(\*STDERR,">&=2")if ($do_stderr || $do_merge)&& tied*STDERR && $] >= 5.008;my%proxy_std=_proxy_std();$layers{stdout}=[PerlIO::get_layers(\*STDOUT,output=>1)]if$proxy_std{stdout};$layers{stderr}=[PerlIO::get_layers(\*STDERR,output=>1)]if$proxy_std{stderr};$stash->{old}=_copy_std();$stash->{new}={%{$stash->{old}}};for (keys%do){$stash->{new}{$_}=($stash->{capture}{$_}||= File::Temp->new);seek($stash->{capture}{$_},0,2)or die "Could not seek on capture handle for $_\n";$stash->{pos}{$_}=tell$stash->{capture}{$_};_start_tee($_=>$stash)if$do_tee}_wait_for_tees($stash)if$do_tee;$stash->{new}{stderr}=$stash->{new}{stdout}if$do_merge;_open_std($stash->{new});my ($exit_code,$inner_error,$outer_error,$orig_pid,@result);{$orig_pid=$$;local*STDIN=*CT_ORIG_STDIN if$localize{stdin};_relayer(\*STDOUT,$layers{stdout})if$do_stdout;_relayer(\*STDERR,$layers{stderr})if$do_stderr;my$old_eval_err=$@;undef $@;eval {@result=$code->();$inner_error=$@};$exit_code=$?;$outer_error=$@;STDOUT->flush if$do_stdout;STDERR->flush if$do_stderr;$@=$old_eval_err}_open_std($stash->{old});_close($_)for values %{$stash->{old}};_relayer(\*STDOUT,$layers{stdout})if$do_stdout;_relayer(\*STDERR,$layers{stderr})if$do_stderr;_unproxy(%proxy_std);_kill_tees($stash)if$do_tee;my%got;if ($orig_pid==$$ and (defined wantarray or ($do_tee && keys%localize))){for (keys%do){_relayer($stash->{capture}{$_},$layers{$_});$got{$_}=_slurp($_,$stash)}print CT_ORIG_STDOUT$got{stdout}if$do_stdout && $do_tee && $localize{stdout};print CT_ORIG_STDERR$got{stderr}if$do_stderr && $do_tee && $localize{stderr}}$?=$exit_code;$@=$inner_error if$inner_error;die$outer_error if$outer_error;return unless defined wantarray;my@return;push@return,$got{stdout}if$do_stdout;push@return,$got{stderr}if$do_stderr &&!$do_merge;push@return,@result;return wantarray ? @return : $return[0]}1;
  use Fcntl;
  $SIG{HUP}=sub{exit};
  if ( my $fn=shift ) {
      sysopen(my $fh, qq{$fn}, O_WRONLY|O_CREAT|O_EXCL) or die $!;
      print {$fh} $$;
      close $fh;
  }
  my $buf; while (sysread(STDIN, $buf, 2048)) {
      syswrite(STDOUT, $buf); syswrite(STDERR, $buf);
  }
  HERE
CAPTURE_TINY

$fatpacked{"Class/Accessor/Lite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_ACCESSOR_LITE';
  package Class::Accessor::Lite;use strict;our$VERSION='0.08';sub croak {require Carp;Carp::croak(@_)}sub import {shift;my%args=@_;my$pkg=caller(0);my%key_ctor=(rw=>\&_mk_accessors,ro=>\&_mk_ro_accessors,wo=>\&_mk_wo_accessors,);for my$key (sort keys%key_ctor){if (defined$args{$key}){croak("value of the '$key' parameter should be an arrayref")unless ref($args{$key})eq 'ARRAY';$key_ctor{$key}->($pkg,@{$args{$key}})}}_mk_new($pkg)if$args{new};1}sub mk_new_and_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_new($pkg);_mk_accessors($pkg,@properties)}sub mk_new {my$pkg=caller(0);_mk_new($pkg)}sub mk_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_accessors($pkg,@properties)}sub mk_ro_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_ro_accessors($pkg,@properties)}sub mk_wo_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_wo_accessors($pkg,@properties)}sub _mk_new {my$pkg=shift;no strict 'refs';*{$pkg .'::new'}=__m_new($pkg)}sub _mk_accessors {my$pkg=shift;no strict 'refs';for my$n (@_){*{$pkg .'::' .$n}=__m($n)}}sub _mk_ro_accessors {my$pkg=shift;no strict 'refs';for my$n (@_){*{$pkg .'::' .$n}=__m_ro($pkg,$n)}}sub _mk_wo_accessors {my$pkg=shift;no strict 'refs';for my$n (@_){*{$pkg .'::' .$n}=__m_wo($pkg,$n)}}sub __m_new {my$pkg=shift;no strict 'refs';return sub {my$klass=shift;bless {(@_==1 && ref($_[0])eq 'HASH' ? %{$_[0]}: @_),},$klass}}sub __m {my$n=shift;sub {return $_[0]->{$n}if @_==1;return $_[0]->{$n}=$_[1]if @_==2;shift->{$n}=\@_}}sub __m_ro {my ($pkg,$n)=@_;sub {if (@_==1){return $_[0]->{$n}if @_==1}else {my$caller=caller(0);croak("'$caller' cannot access the value of '$n' on objects of class '$pkg'")}}}sub __m_wo {my ($pkg,$n)=@_;sub {if (@_==1){my$caller=caller(0);croak("'$caller' cannot alter the value of '$n' on objects of class '$pkg'")}else {return $_[0]->{$n}=$_[1]if @_==2;shift->{$n}=\@_}}}1;
CLASS_ACCESSOR_LITE

$fatpacked{"ExtUtils/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CONFIG';
  package ExtUtils::Config;$ExtUtils::Config::VERSION='0.008';use strict;use warnings;use Config;use Data::Dumper ();sub new {my ($pack,$args)=@_;return bless {values=>($args ? {%$args }: {}),},$pack}sub get {my ($self,$key)=@_;return exists$self->{values}{$key}? $self->{values}{$key}: $Config{$key}}sub exists {my ($self,$key)=@_;return exists$self->{values}{$key}|| exists$Config{$key}}sub values_set {my$self=shift;return {%{$self->{values}}}}sub all_config {my$self=shift;return {%Config,%{$self->{values}}}}sub serialize {my$self=shift;return$self->{serialized}||= Data::Dumper->new([$self->values_set])->Terse(1)->Sortkeys(1)->Dump}1;
EXTUTILS_CONFIG

$fatpacked{"ExtUtils/Helpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS';
  package ExtUtils::Helpers;$ExtUtils::Helpers::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';use Config;use File::Basename qw/basename/;use File::Spec::Functions qw/splitpath canonpath abs2rel splitdir/;use Text::ParseWords 3.24 ();our@EXPORT_OK=qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;BEGIN {my%impl_for=(MSWin32=>'Windows',VMS=>'VMS');my$package='ExtUtils::Helpers::' .($impl_for{$^O}|| 'Unix');my$impl=$impl_for{$^O}|| 'Unix';require "ExtUtils/Helpers/$impl.pm";"ExtUtils::Helpers::$impl"->import()}sub split_like_shell {my ($string)=@_;return if not defined$string;$string =~ s/^\s+|\s+$//g;return if not length$string;return Text::ParseWords::shellwords($string)}sub man1_pagename {my$filename=shift;return basename($filename).".$Config{man1ext}"}my%separator=(MSWin32=>'.',VMS=>'__',os2=>'.',cygwin=>'.',);my$separator=$separator{$^O}|| '::';sub man3_pagename {my ($filename,$base)=@_;$base ||= 'lib';my ($vols,$dirs,$file)=splitpath(canonpath(abs2rel($filename,$base)));$file=basename($file,qw/.pm .pod/);my@dirs=grep {length}splitdir($dirs);return join$separator,@dirs,"$file.$Config{man3ext}"}1;
EXTUTILS_HELPERS

$fatpacked{"ExtUtils/Helpers/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_UNIX';
  package ExtUtils::Helpers::Unix;$ExtUtils::Helpers::Unix::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Carp qw/croak/;use Config;my$layer=$] >= 5.008001 ? ":raw" : "";sub make_executable {my$filename=shift;my$current_mode=(stat$filename)[2]+ 0;if (-T $filename){open my$fh,"<$layer",$filename;my@lines=<$fh>;if (@lines and $lines[0]=~ s{ \A \#! \s* (?:/\S+/)? perl \b (.*) \z }{$Config{startperl}$1}xms){open my$out,">$layer","$filename.new" or croak "Couldn't open $filename.new: $!";print$out @lines;close$out;rename$filename,"$filename.bak" or croak "Couldn't rename $filename to $filename.bak";rename "$filename.new",$filename or croak "Couldn't rename $filename.new to $filename";unlink "$filename.bak"}}chmod$current_mode | oct(111),$filename;return}sub detildefy {my$value=shift;for ($value){s{ ^ ~ (?= /|$)}          [ $ENV{HOME} || (getpwuid $>)[7] ]ex or s{ ^ ~ ([^/]+) (?= /|$) } { (getpwnam $1)[7] || "~$1" }ex}return$value}1;
EXTUTILS_HELPERS_UNIX

$fatpacked{"ExtUtils/Helpers/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_VMS';
  package ExtUtils::Helpers::VMS;$ExtUtils::Helpers::VMS::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use File::Copy qw/copy/;sub make_executable {my$filename=shift;my$batchname="$filename.com";copy($filename,$batchname);ExtUtils::Helpers::Unix::make_executable($batchname);return}sub detildefy {my$arg=shift;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);unless ($arg =~ m#^~/#){shift@dirs}my$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs);$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}
EXTUTILS_HELPERS_VMS

$fatpacked{"ExtUtils/Helpers/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_WINDOWS';
  package ExtUtils::Helpers::Windows;$ExtUtils::Helpers::Windows::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Config;use Carp qw/carp croak/;use ExtUtils::PL2Bat 'pl2bat';sub make_executable {my$script=shift;if (-T $script && $script !~ / \. (?:bat|cmd) $ /x){pl2bat(in=>$script,update=>1)}return}sub detildefy {my$value=shift;$value =~ s{ ^ ~ (?= [/\\] | $ ) }[$ENV{USERPROFILE}]x if$ENV{USERPROFILE};return$value}1;
EXTUTILS_HELPERS_WINDOWS

$fatpacked{"ExtUtils/InstallPaths.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_INSTALLPATHS';
  package ExtUtils::InstallPaths;$ExtUtils::InstallPaths::VERSION='0.012';use 5.006;use strict;use warnings;use File::Spec ();use Carp ();use ExtUtils::Config 0.002;my%complex_accessors=map {$_=>1}qw/prefix_relpaths install_sets/;my%hash_accessors=map {$_=>1}qw/install_path install_base_relpaths original_prefix/;my%defaults=(installdirs=>'site',install_base=>undef,prefix=>undef,verbose=>0,create_packlist=>1,dist_name=>undef,module_name=>undef,destdir=>undef,install_path=>sub {{}},install_sets=>\&_default_install_sets,original_prefix=>\&_default_original_prefix,install_base_relpaths=>\&_default_base_relpaths,prefix_relpaths=>\&_default_prefix_relpaths,);sub _merge_shallow {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);$filter->($_)for grep$filter,values %$override;return {%$defaults,%$override }}}sub _merge_deep {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);my$pair_for=sub {my$key=shift;my%override=%{$override->{$key}|| {}};$filter && $filter->($_)for values%override;return$key=>{%{$defaults->{$key}},%override }};return {map {$pair_for->($_)}keys %$defaults }}}my%allowed_installdir=map {$_=>1}qw/core site vendor/;my$must_be_relative=sub {Carp::croak('Value must be a relative path')if File::Spec->file_name_is_absolute($_[0])};my%deep_filter=map {$_=>$must_be_relative}qw/install_base_relpaths prefix_relpaths/;my%filter=(installdirs=>sub {my$value=shift;$value='core',Carp::carp('Perhaps you meant installdirs to be "core" rather than "perl"?')if$value eq 'perl';Carp::croak('installdirs must be one of "core", "site", or "vendor"')if not $allowed_installdir{$value};return$value},(map {$_=>_merge_shallow($_,$deep_filter{$_})}qw/original_prefix install_base_relpaths/),(map {$_=>_merge_deep($_,$deep_filter{$_})}qw/install_sets prefix_relpaths/),);sub new {my ($class,%args)=@_;my$config=$args{config}|| ExtUtils::Config->new;my%self=(config=>$config,map {$_=>exists$args{$_}? $filter{$_}? $filter{$_}->($args{$_},$config): $args{$_}: ref$defaults{$_}? $defaults{$_}->($config): $defaults{$_}}keys%defaults,);$self{module_name}||= do {my$module_name=$self{dist_name};$module_name =~ s/-/::/g;$module_name}if defined$self{dist_name};return bless \%self,$class}for my$attribute (keys%defaults){no strict qw/refs/;*{$attribute}=$hash_accessors{$attribute}? sub {my ($self,$key)=@_;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$key}}: $complex_accessors{$attribute}? sub {my ($self,$installdirs,$key)=@_;Carp::confess("$attribute needs installdir")if not defined$installdirs;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$installdirs}{$key}}: sub {my$self=shift;return$self->{$attribute}}}my$script=$] > 5.008000 ? 'script' : 'bin';my@install_sets_keys=qw/lib arch bin script bindoc libdoc binhtml libhtml/;my@install_sets_tail=('bin',$script,qw/man1dir man3dir html1dir html3dir/);my%install_sets_values=(core=>[qw/privlib archlib/,@install_sets_tail ],site=>[map {"site$_"}qw/lib arch/,@install_sets_tail ],vendor=>[map {"vendor$_"}qw/lib arch/,@install_sets_tail ],);sub _default_install_sets {my$c=shift;my%ret;for my$installdir (qw/core site vendor/){@{$ret{$installdir}}{@install_sets_keys}=map {$c->get("install$_")}@{$install_sets_values{$installdir}}}return \%ret}sub _default_base_relpaths {my$config=shift;return {lib=>['lib','perl5'],arch=>['lib','perl5',$config->get('archname')],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],}}my%common_prefix_relpaths=(bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],);sub _default_prefix_relpaths {my$c=shift;my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');return {core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],%common_prefix_relpaths,},}}sub _default_original_prefix {my$c=shift;my%ret=(core=>$c->get('installprefixexp'),site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',);return \%ret}sub _log_verbose {my$self=shift;print @_ if$self->verbose;return}sub is_default_installable {my$self=shift;my$type=shift;my$installable=$self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs,$type));return$installable ? 1 : 0}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->_log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return File::Spec->catdir(@{$default})}}sub _prefixify_novms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m{/$};$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined$path && length$path;if (not defined$path or length$path==0){$self->_log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->_log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->_log_verbose("    now $path in $rprefix\n");return$path}sub _catprefix_vms {my ($self,$rprefix,$default)=@_;my ($rvol,$rdirs)=File::Spec->splitpath($rprefix);if ($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify_vms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n");require VMS::Filespec;$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->_log_verbose("  rprefix translated to $rprefix\n  sprefix translated to $sprefix\n");if (length($path)==0){$self->_log_verbose("  no path to prefixify.\n")}elsif (!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("	path is relative, not prefixifying.\n")}elsif ($sprefix eq $rprefix){$self->_log_verbose("  no new prefix.\n")}else {my ($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config->get('vms_prefix');if ($path_vol eq $vms_prefix.':'){$self->_log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix_vms($rprefix,$path_dirs)}else {$self->_log_verbose("	cannot prefixify.\n");return File::Spec->catdir($self->prefix_relpaths($self->installdirs,$type))}}$self->_log_verbose("	now $path\n");return$path}BEGIN {*_prefixify=$^O eq 'VMS' ? \&_prefixify_vms : \&_prefixify_novms}sub prefix_relative {my ($self,$installdirs,$type)=@_;my$relpath=$self->install_sets($installdirs,$type);return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type)}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,@{$relpath}): undef}if ($self->prefix){my$relpath=$self->prefix_relative($self->installdirs,$type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs,$type)}sub install_types {my$self=shift;my%types=(%{$self->{install_path}},$self->install_base ? %{$self->{install_base_relpaths}}: $self->prefix ? %{$self->{prefix_relpaths}{$self->installdirs }}: %{$self->{install_sets}{$self->installdirs }});return sort keys%types}sub install_map {my ($self,$dirs)=@_;my%localdir_for;if ($dirs && %$dirs){%localdir_for=%$dirs}else {for my$type ($self->install_types){$localdir_for{$type}=File::Spec->catdir('blib',$type)}}my (%map,@skipping);for my$type (keys%localdir_for){next if not -e $localdir_for{$type};if (my$dest=$self->install_destination($type)){$map{$localdir_for{$type}}=$dest}else {push@skipping,$type}}warn "WARNING: Can't figure out install path for types: @skipping\nFiles will not be installed.\n" if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}1;
EXTUTILS_INSTALLPATHS

$fatpacked{"HTTP/Date.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_DATE';
  package HTTP::Date;$VERSION="6.02";require Exporter;@ISA=qw(Exporter);@EXPORT=qw(time2str str2time);@EXPORT_OK=qw(parse_date time2iso time2isoz);use strict;require Time::Local;use vars qw(@DoW @MoY %MoY);@DoW=qw(Sun Mon Tue Wed Thu Fri Sat);@MoY=qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);@MoY{@MoY}=(1..12);my%GMT_ZONE=(GMT=>1,UTC=>1,UT=>1,Z=>1);sub time2str (;$) {my$time=shift;$time=time unless defined$time;my ($sec,$min,$hour,$mday,$mon,$year,$wday)=gmtime($time);sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",$DoW[$wday],$mday,$MoY[$mon],$year+1900,$hour,$min,$sec)}sub str2time ($;$) {my$str=shift;return undef unless defined$str;if ($str =~ /^[SMTWF][a-z][a-z], (\d\d) ([JFMAJSOND][a-z][a-z]) (\d\d\d\d) (\d\d):(\d\d):(\d\d) GMT$/){return eval {my$t=Time::Local::timegm($6,$5,$4,$1,$MoY{$2}-1,$3);$t < 0 ? undef : $t}}my@d=parse_date($str);return undef unless@d;$d[1]--;my$tz=pop(@d);unless (defined$tz){unless (defined($tz=shift)){return eval {my$frac=$d[-1];$frac -= ($d[-1]=int($frac));my$t=Time::Local::timelocal(reverse@d)+ $frac;$t < 0 ? undef : $t}}}my$offset=0;if ($GMT_ZONE{uc$tz}){}elsif ($tz =~ /^([-+])?(\d\d?):?(\d\d)?$/){$offset=3600 * $2;$offset += 60 * $3 if $3;$offset *= -1 if $1 && $1 eq '-'}else {eval {require Time::Zone}|| return undef;$offset=Time::Zone::tz_offset($tz);return undef unless defined$offset}return eval {my$frac=$d[-1];$frac -= ($d[-1]=int($frac));my$t=Time::Local::timegm(reverse@d)+ $frac;$t < 0 ? undef : $t - $offset}}sub parse_date ($) {local($_)=shift;return unless defined;s/^\s+//;s/^(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)[a-z]*,?\s*//i;my($day,$mon,$yr,$hr,$min,$sec,$tz,$ampm);(($day,$mon,$yr,$hr,$min,$sec,$tz)=/^
  	 (\d\d?)               # day
  	    (?:\s+|[-\/])
  	 (\w+)                 # month
  	    (?:\s+|[-\/])
  	 (\d+)                 # year
  	 (?:
  	       (?:\s+|:)       # separator before clock
  	    (\d\d?):(\d\d)     # hour:min
  	    (?::(\d\d))?       # optional seconds
  	 )?                    # optional clock
  	    \s*
  	 ([-+]?\d{2,4}|(?![APap][Mm]\b)[A-Za-z]+)? # timezone
  	    \s*
  	 (?:\(\w+\)|\w{3,})?   # ASCII representation of timezone.
  	    \s*$
  	/x)|| (($mon,$day,$hr,$min,$sec,$tz,$yr)=/^
  	 (\w{1,3})             # month
  	    \s+
  	 (\d\d?)               # day
  	    \s+
  	 (\d\d?):(\d\d)        # hour:min
  	 (?::(\d\d))?          # optional seconds
  	    \s+
  	 (?:([A-Za-z]+)\s+)?   # optional timezone
  	 (\d+)                 # year
  	    \s*$               # allow trailing whitespace
  	/x)|| (($mon,$day,$yr,$hr,$min,$sec)=/^
  	 (\w{3})               # month
  	    \s+
  	 (\d\d?)               # day
  	    \s+
  	 (?:
  	    (\d\d\d\d) |       # year
  	    (\d{1,2}):(\d{2})  # hour:min
              (?::(\d\d))?       # optional seconds
  	 )
  	 \s*$
         /x)|| (($yr,$mon,$day,$hr,$min,$sec,$tz)=/^
  	  (\d{4})              # year
  	     [-\/]?
  	  (\d\d?)              # numerical month
  	     [-\/]?
  	  (\d\d?)              # day
  	 (?:
  	       (?:\s+|[-:Tt])  # separator before clock
  	    (\d\d?):?(\d\d)    # hour:min
  	    (?::?(\d\d(?:\.\d*)?))?  # optional seconds (and fractional)
  	 )?                    # optional clock
  	    \s*
  	 ([-+]?\d\d?:?(:?\d\d)?
  	  |Z|z)?               # timezone  (Z is "zero meridian", i.e. GMT)
  	    \s*$
  	/x)|| (($mon,$day,$yr,$hr,$min,$ampm)=/^
            (\d{2})                # numerical month
               -
            (\d{2})                # day
               -
            (\d{2})                # year
               \s+
            (\d\d?):(\d\d)([APap][Mm])  # hour:min AM or PM
               \s*$
          /x)|| return;$mon=$MoY{$mon}|| $MoY{"\u\L$mon"}|| ($mon =~ /^\d\d?$/ && $mon >= 1 && $mon <= 12 && int($mon))|| return;unless (defined$yr){my$cur_mon;($cur_mon,$yr)=(localtime)[4,5];$yr += 1900;$cur_mon++;$yr-- if$mon > $cur_mon}elsif (length($yr)< 3){my$cur_yr=(localtime)[5]+ 1900;my$m=$cur_yr % 100;my$tmp=$yr;$yr += $cur_yr - $m;$m -= $tmp;$yr += ($m > 0)? 100 : -100 if abs($m)> 50}$hr=0 unless defined($hr);$min=0 unless defined($min);$sec=0 unless defined($sec);if ($ampm){$ampm=uc$ampm;$hr=0 if$hr==12 && $ampm eq 'AM';$hr += 12 if$ampm eq 'PM' && $hr!=12}return($yr,$mon,$day,$hr,$min,$sec,$tz)if wantarray;if (defined$tz){$tz="Z" if$tz =~ /^(GMT|UTC?|[-+]?0+)$/}else {$tz=""}return sprintf("%04d-%02d-%02d %02d:%02d:%02d%s",$yr,$mon,$day,$hr,$min,$sec,$tz)}sub time2iso (;$) {my$time=shift;$time=time unless defined$time;my($sec,$min,$hour,$mday,$mon,$year)=localtime($time);sprintf("%04d-%02d-%02d %02d:%02d:%02d",$year+1900,$mon+1,$mday,$hour,$min,$sec)}sub time2isoz (;$) {my$time=shift;$time=time unless defined$time;my($sec,$min,$hour,$mday,$mon,$year)=gmtime($time);sprintf("%04d-%02d-%02d %02d:%02d:%02dZ",$year+1900,$mon+1,$mday,$hour,$min,$sec)}1;
HTTP_DATE

$fatpacked{"Hash/Rename.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HASH_RENAME';
  package Hash::Rename;use strict;use warnings;use Exporter qw(import);our$VERSION='2.00';our@EXPORT=('hash_rename');sub hash_rename (\%@) {my ($hash,%args)=@_;my%new_hash;for my$key (sort keys %$hash){my$orig_key=$key;$key=$args{prepend}.$key if defined$args{prepend};$key=$key .$args{append}if defined$args{append};if (defined$args{code}){ref$args{code}eq 'CODE' || die "'code' value is not a CODE reference";local $_=$key;$args{code}->();$key=$_}die "duplicate result key [$key] from original key [$orig_key]\n" if defined($args{strict})&& exists$new_hash{$key};my$val=$hash->{$orig_key};if ($args{recurse}&& (ref($val)|| '')eq 'HASH'){&hash_rename($val,%args)}$new_hash{$key}=$val}%$hash=%new_hash}1;
HASH_RENAME

$fatpacked{"Module/Build/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_TINY';
  package Module::Build::Tiny;$Module::Build::Tiny::VERSION='0.039';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=qw/Build Build_PL/;use CPAN::Meta;use ExtUtils::Config 0.003;use ExtUtils::Helpers 0.020 qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;use ExtUtils::Install qw/pm_to_blib install/;use ExtUtils::InstallPaths 0.002;use File::Basename qw/basename dirname/;use File::Find ();use File::Path qw/mkpath rmtree/;use File::Spec::Functions qw/catfile catdir rel2abs abs2rel splitdir curdir/;use Getopt::Long 2.36 qw/GetOptionsFromArray/;use JSON::PP 2 qw/encode_json decode_json/;sub write_file {my ($filename,$content)=@_;open my$fh,'>',$filename or die "Could not open $filename: $!\n";print$fh $content}sub read_file {my ($filename,$mode)=@_;open my$fh,'<',$filename or die "Could not open $filename: $!\n";return do {local $/;<$fh>}}sub get_meta {my ($metafile)=grep {-e $_}qw/META.json META.yml/ or die "No META information provided\n";return CPAN::Meta->load_file($metafile)}sub manify {my ($input_file,$output_file,$section,$opts)=@_;return if -e $output_file && -M $input_file <= -M $output_file;my$dirname=dirname($output_file);mkpath($dirname,$opts->{verbose})if not -d $dirname;require Pod::Man;Pod::Man->new(section=>$section)->parse_from_file($input_file,$output_file);print "Manifying $output_file\n" if$opts->{verbose}&& $opts->{verbose}> 0;return}sub process_xs {my ($source,$options)=@_;die "Can't build xs files under --pureperl-only\n" if$options->{'pureperl-only'};my (undef,@parts)=splitdir(dirname($source));push@parts,my$file_base=basename($source,'.xs');my$archdir=catdir(qw/blib arch auto/,@parts);my$tempdir='temp';my$c_file=catfile($tempdir,"$file_base.c");require ExtUtils::ParseXS;mkpath($tempdir,$options->{verbose},oct '755');ExtUtils::ParseXS::process_file(filename=>$source,prototypes=>0,output=>$c_file);my$version=$options->{meta}->version;require ExtUtils::CBuilder;my$builder=ExtUtils::CBuilder->new(config=>$options->{config}->values_set);my$ob_file=$builder->compile(source=>$c_file,defines=>{VERSION=>qq/"$version"/,XS_VERSION=>qq/"$version"/ },include_dirs=>[curdir,dirname($source)]);require DynaLoader;my$mod2fname=defined&DynaLoader::mod2fname ? \&DynaLoader::mod2fname : sub {return $_[0][-1]};mkpath($archdir,$options->{verbose},oct '755')unless -d $archdir;my$lib_file=catfile($archdir,$mod2fname->(\@parts).'.' .$options->{config}->get('dlext'));return$builder->link(objects=>$ob_file,lib_file=>$lib_file,module_name=>join '::',@parts)}sub find {my ($pattern,$dir)=@_;my@ret;File::Find::find(sub {push@ret,$File::Find::name if /$pattern/ && -f},$dir)if -d $dir;return@ret}my%actions=(build=>sub {my%opt=@_;for my$pl_file (find(qr/\.PL$/,'lib')){(my$pm=$pl_file)=~ s/\.PL$//;system $^X,$pl_file,$pm and die "$pl_file returned $?\n"}my%modules=map {$_=>catfile('blib',$_)}find(qr/\.p(?:m|od)$/,'lib');my%scripts=map {$_=>catfile('blib',$_)}find(qr//,'script');my%shared=map {$_=>catfile(qw/blib lib auto share dist/,$opt{meta}->name,abs2rel($_,'share'))}find(qr//,'share');pm_to_blib({%modules,%scripts,%shared},catdir(qw/blib lib auto/));make_executable($_)for values%scripts;mkpath(catdir(qw/blib arch/),$opt{verbose});process_xs($_,\%opt)for find(qr/.xs$/,'lib');if ($opt{install_paths}->install_destination('bindoc')&& $opt{install_paths}->is_default_installable('bindoc')){manify($_,catfile('blib','bindoc',man1_pagename($_)),$opt{config}->get('man1ext'),\%opt)for keys%scripts}if ($opt{install_paths}->install_destination('libdoc')&& $opt{install_paths}->is_default_installable('libdoc')){manify($_,catfile('blib','libdoc',man3_pagename($_)),$opt{config}->get('man3ext'),\%opt)for keys%modules}},test=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';require TAP::Harness::Env;my%test_args=((verbosity=>$opt{verbose})x!!exists$opt{verbose},(jobs=>$opt{jobs})x!!exists$opt{jobs},(color=>1)x!!-t STDOUT,lib=>[map {rel2abs(catdir(qw/blib/,$_))}qw/arch lib/ ],);my$tester=TAP::Harness::Env->create(\%test_args);$tester->runtests(sort +find(qr/\.t$/,'t'))->has_errors and exit 1},install=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';install($opt{install_paths}->install_map,@opt{qw/verbose dry_run uninst/})},clean=>sub {my%opt=@_;rmtree($_,$opt{verbose})for qw/blib temp/},realclean=>sub {my%opt=@_;rmtree($_,$opt{verbose})for qw/blib temp Build _build_params MYMETA.yml MYMETA.json/},);sub Build {my$action=@ARGV && $ARGV[0]=~ /\A\w+\z/ ? shift@ARGV : 'build';die "No such action '$action'\n" if not $actions{$action};my($env,$bargv)=@{decode_json(read_file('_build_params'))};my%opt;GetOptionsFromArray($_,\%opt,qw/install_base=s install_path=s% installdirs=s destdir=s prefix=s config=s% uninst:1 verbose:1 dry_run:1 pureperl-only:1 create_packlist=i jobs=i/)for ($env,$bargv,\@ARGV);$_=detildefy($_)for grep {defined}@opt{qw/install_base destdir prefix/},values %{$opt{install_path}};@opt{'config','meta' }=(ExtUtils::Config->new($opt{config}),get_meta());$actions{$action}->(%opt,install_paths=>ExtUtils::InstallPaths->new(%opt,dist_name=>$opt{meta}->name))}sub Build_PL {my$meta=get_meta();printf "Creating new 'Build' script for '%s' version '%s'\n",$meta->name,$meta->version;my$dir=$meta->name eq 'Module-Build-Tiny' ? "use lib 'lib';" : '';write_file('Build',"#!perl\n$dir\nuse Module::Build::Tiny;\nBuild();\n");make_executable('Build');my@env=defined$ENV{PERL_MB_OPT}? split_like_shell($ENV{PERL_MB_OPT}): ();write_file('_build_params',encode_json([\@env,\@ARGV ]));$meta->save(@$_)for ['MYMETA.json'],['MYMETA.yml'=>{version=>1.4 }]}1;
MODULE_BUILD_TINY

$fatpacked{"Sub/Uplevel.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_UPLEVEL';
  package Sub::Uplevel;use 5.006;use strict;our$VERSION='0.2800';our$CHECK_FRAMES;BEGIN {$CHECK_FRAMES=!!$CHECK_FRAMES}use constant CHECK_FRAMES=>$CHECK_FRAMES;if (not defined*CORE::GLOBAL::caller{CODE}){*CORE::GLOBAL::caller=\&_normal_caller}my@reload_list=qw/Exporter Exporter::Heavy/;sub import {no strict 'refs';my ($class,@args)=@_;for my$tag (@args,'uplevel'){if ($tag eq 'uplevel'){my$caller=caller(0);*{"$caller\::uplevel"}=\&uplevel}elsif($tag eq ':aggressive'){_force_reload(@reload_list)}else {die qq{"$tag" is not exported by the $class module\n}}}return}sub _force_reload {no warnings 'redefine';local $^W=0;for my$m (@_){$m =~ s{::}{/}g;$m .= ".pm";require$m if delete$INC{$m}}}our (@Up_Frames,$Caller_Proxy);sub _apparent_stack_height {my$height=1;while (1){last if!defined scalar$Caller_Proxy->($height);$height++}return$height - 1}sub uplevel {my$old_W=$^W;$^W=0;local$Caller_Proxy=*CORE::GLOBAL::caller{CODE}if*CORE::GLOBAL::caller{CODE}!=\&_uplevel_caller;local*CORE::GLOBAL::caller=\&_uplevel_caller;$^W=$old_W;if (CHECK_FRAMES and $_[0]>= _apparent_stack_height()){require Carp;Carp::carp("uplevel $_[0] is more than the caller stack")}local@Up_Frames=(shift,@Up_Frames);my$function=shift;return$function->(@_)}sub _normal_caller (;$) {my ($height)=@_;$height++;my@caller=CORE::caller($height);if (CORE::caller()eq 'DB'){package DB;@caller=CORE::caller($height)}return if!@caller;return$caller[0]if!wantarray;return @_ ? @caller : @caller[0..2]}sub _uplevel_caller (;$) {my$height=$_[0]|| 0;return$Caller_Proxy->($height + 1)if!@Up_Frames;my$saw_uplevel=0;my$adjust=0;my$test_caller;for (my$up=0;$up <= $height + $adjust;$up++ ){$test_caller=scalar CORE::caller($up + 1);if($test_caller && $test_caller eq __PACKAGE__){$adjust += 1 + $Up_Frames[$saw_uplevel];$saw_uplevel++}}my@caller=$Caller_Proxy->($height + $adjust + 1);if (CORE::caller()eq 'DB'){package DB;@caller=$Sub::Uplevel::Caller_Proxy->($height + $adjust + 1)}return if!@caller;return$caller[0]if!wantarray;return @_ ? @caller : @caller[0..2]}1;
SUB_UPLEVEL

$fatpacked{"Test/Differences.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DIFFERENCES';
  package Test::Differences;our$VERSION="0.64";$VERSION=eval$VERSION;use Exporter;@ISA=qw(Exporter);@EXPORT=qw(eq_or_diff eq_or_diff_text eq_or_diff_data unified_diff context_diff oldstyle_diff table_diff);use strict;use Carp;use Text::Diff;use Data::Dumper;{my$diff_style='Table';my%allowed_style=map {$_=>1}qw/Unified Context OldStyle Table/;sub _diff_style {return$diff_style unless @_;my$requested_style=shift;unless ($allowed_style{$requested_style}){Carp::croak("Uknown style ($requested_style) requested for diff")}$diff_style=$requested_style}}sub unified_diff {_diff_style('Unified')}sub context_diff {_diff_style('Context')}sub oldstyle_diff {_diff_style('OldStyle')}sub table_diff {_diff_style('Table')}sub _identify_callers_test_package_of_choice {my$has_builder_pm=grep $_ eq "Test/Builder.pm",keys%INC;my$has_test_pm=grep $_ eq "Test.pm",keys%INC;return "Test" if$has_test_pm &&!$has_builder_pm;return "Test::Builder" if!$has_test_pm && $has_builder_pm;if ($has_test_pm && $has_builder_pm){return "Test::Builder"}}my$warned_of_unknown_test_lib;sub eq_or_diff_text {$_[3]={data_type=>"text" };goto&eq_or_diff}sub eq_or_diff_data {$_[3]={data_type=>"data" };goto&eq_or_diff}my$joint=chr(0)."A" .chr(1);sub eq_or_diff {my (@vals,$name,$options);$options=pop if @_ > 2 && ref $_[-1];($vals[0],$vals[1],$name)=@_;my($data_type,$filename_a,$filename_b);if($options){$data_type=$options->{data_type};$filename_a=$options->{filename_a};$filename_b=$options->{filename_b}}$data_type ||= "text" unless ref$vals[0]|| ref$vals[1];$data_type ||= "data";$filename_a ||= 'Got';$filename_b ||= 'Expected';my@widths;local$Data::Dumper::Indent=1;local$Data::Dumper::Purity=0;local$Data::Dumper::Terse=1;local$Data::Dumper::Deepcopy=1;local$Data::Dumper::Quotekeys=0;local$Data::Dumper::Useperl=1;local$Data::Dumper::Sortkeys=exists$options->{Sortkeys}? $options->{Sortkeys}: 1;my ($got,$expected)=map [split /^/,Data::Dumper::Dumper($_)],@vals;my$caller=caller;my$passed =join($joint,@$got)eq join($joint,@$expected);my$diff;unless ($passed){my$context;$context=$options->{context}if exists$options->{context};$context=2**31 unless defined$context;confess "context must be an integer: '$context'\n" unless$context =~ /\A\d+\z/;$diff=diff$got,$expected,{CONTEXT=>$context,STYLE=>_diff_style(),FILENAME_A=>$filename_a,FILENAME_B=>$filename_b,OFFSET_A=>$data_type eq "text" ? 1 : 0,OFFSET_B=>$data_type eq "text" ? 1 : 0,INDEX_LABEL=>$data_type eq "text" ? "Ln" : "Elt",};chomp$diff;$diff .= "\n"}my$which=_identify_callers_test_package_of_choice;if ($which eq "Test"){@_ =$passed ? ("","",$name): ("\n$diff","No differences",$name);goto&Test::ok}elsif ($which eq "Test::Builder"){my$test=Test::Builder->new;$test->ok($passed,$name);$test->diag($diff)unless$passed}else {unless ($warned_of_unknown_test_lib){Carp::cluck "Can't identify test lib in use, doesn't seem to be Test.pm or Test::Builder based\n";$warned_of_unknown_test_lib=1}if ($passed){print "ok\n"}else {$diff =~ s/^/# /gm;print "not ok\n",$diff}}}1;
TEST_DIFFERENCES

$fatpacked{"Test/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_EXCEPTION';
  use strict;use warnings;package Test::Exception;use Test::Builder;use Sub::Uplevel qw(uplevel);use base qw(Exporter);our$VERSION='0.43';$VERSION=eval$VERSION;our@EXPORT=qw(dies_ok lives_ok throws_ok lives_and);my$Tester=Test::Builder->new;sub import {my$self=shift;if (@_){my$package=caller;$Tester->exported_to($package);$Tester->plan(@_)};$self->export_to_level(1,$self,$_)foreach@EXPORT}sub _quiet_caller (;$) {my$height=$_[0];$height++;if (CORE::caller()eq 'DB'){package DB;if(wantarray){if (!@_){return (CORE::caller($height))[0..2]}else {my@frame_info=CORE::caller($height);@DB::args=();return@frame_info}}return CORE::caller($height)}else {if(wantarray and!@_){return (CORE::caller($height))[0..2]}else {return CORE::caller($height)}}}sub _try_as_caller {my$coderef=shift;local*CORE::GLOBAL::caller;{no warnings 'redefine';*CORE::GLOBAL::caller=\&_quiet_caller}eval {uplevel 3,$coderef};return $@};sub _is_exception {my$exception=shift;return ref$exception || $exception ne ''};sub _exception_as_string {my ($prefix,$exception)=@_;return "$prefix normal exit" unless _is_exception($exception);my$class=ref$exception;$exception="$class ($exception)" if$class && "$exception" !~ m/^\Q$class/;chomp$exception;return "$prefix $exception"};sub throws_ok (&$;$) {my ($coderef,$expecting,$description)=@_;unless (defined$expecting){require Carp;Carp::croak("throws_ok: must pass exception class/object or regex")}$description=_exception_as_string("threw",$expecting)unless defined$description;my$exception=_try_as_caller($coderef);my$regex=$Tester->maybe_regex($expecting);my$ok=$regex ? ($exception =~ m/$regex/): eval {$exception->isa(ref$expecting ? ref$expecting : $expecting)};$Tester->ok($ok,$description);unless ($ok){$Tester->diag(_exception_as_string("expecting:",$expecting));$Tester->diag(_exception_as_string("found:",$exception))};$@=$exception;return$ok};sub dies_ok (&;$) {my ($coderef,$description)=@_;my$exception=_try_as_caller($coderef);my$ok=$Tester->ok(_is_exception($exception),$description);$@=$exception;return$ok}sub lives_ok (&;$) {my ($coderef,$description)=@_;my$exception=_try_as_caller($coderef);my$ok=$Tester->ok(!_is_exception($exception),$description);$Tester->diag(_exception_as_string("died:",$exception))unless$ok;$@=$exception;return$ok}sub lives_and (&;$) {my ($test,$description)=@_;{my$ok=\&Test::Builder::ok;no warnings;local*Test::Builder::ok=sub {local$Test::Builder::Level=$Test::Builder::Level + 1;$_[2]=$description unless defined $_[2];$ok->(@_)};use warnings;eval {$test->()}and return 1};my$exception=$@;if (_is_exception($exception)){$Tester->ok(0,$description);$Tester->diag(_exception_as_string("died:",$exception))};$@=$exception;return}1;
TEST_EXCEPTION

$fatpacked{"Text/Diff.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_DIFF';
  package Text::Diff;use 5.006;use strict;use warnings;use Carp qw/croak confess/;use Exporter ();use Algorithm::Diff ();our$VERSION='1.45';our@ISA=qw/Exporter/;our@EXPORT=qw/diff/;use constant A=>0;use constant B=>1;use constant OPCODE=>2;use constant FLAG=>3;my%internal_styles=(Unified=>undef,Context=>undef,OldStyle=>undef,Table=>undef,);sub diff {my@seqs=(shift,shift);my$options=shift || {};for my$i (0 .. 1){my$seq=$seqs[$i];my$type=ref$seq;while ($type eq "CODE"){$seqs[$i]=$seq=$seq->($options);$type=ref$seq}my$AorB=!$i ? "A" : "B";if ($type eq "ARRAY"){$options->{"OFFSET_$AorB"}=0 unless defined$options->{"OFFSET_$AorB"}}elsif ($type eq "SCALAR"){$seqs[$i]=[split(/^/m,$$seq)];$options->{"OFFSET_$AorB"}=1 unless defined$options->{"OFFSET_$AorB"}}elsif (!$type){$options->{"OFFSET_$AorB"}=1 unless defined$options->{"OFFSET_$AorB"};$options->{"FILENAME_$AorB"}=$seq unless defined$options->{"FILENAME_$AorB"};$options->{"MTIME_$AorB"}=(stat($seq))[9]unless defined$options->{"MTIME_$AorB"};local $/="\n";open F,"<$seq" or croak "$!: $seq";$seqs[$i]=[<F>];close F}elsif ($type eq "GLOB" || UNIVERSAL::isa($seq,"IO::Handle")){$options->{"OFFSET_$AorB"}=1 unless defined$options->{"OFFSET_$AorB"};local $/="\n";$seqs[$i]=[<$seq>]}else {confess "Can't handle input of type ",ref}}my$output;my$output_handler=$options->{OUTPUT};my$type=ref$output_handler ;if (!defined$output_handler){$output="";$output_handler=sub {$output .= shift}}elsif ($type eq "CODE"){}elsif ($type eq "SCALAR"){my$out_ref=$output_handler;$output_handler=sub {$$out_ref .= shift}}elsif ($type eq "ARRAY"){my$out_ref=$output_handler;$output_handler=sub {push @$out_ref,shift}}elsif ($type eq "GLOB" || UNIVERSAL::isa$output_handler,"IO::Handle"){my$output_handle=$output_handler;$output_handler=sub {print$output_handle shift}}else {croak "Unrecognized output type: $type"}my$style=$options->{STYLE};$style="Unified" unless defined$options->{STYLE};$style="Text::Diff::$style" if exists$internal_styles{$style};if (!$style->can("hunk")){eval "require $style; 1" or die $@}$style=$style->new if!ref$style && $style->can("new");my$ctx_lines=$options->{CONTEXT};$ctx_lines=3 unless defined$ctx_lines;$ctx_lines=0 if$style->isa("Text::Diff::OldStyle");my@keygen_args=$options->{KEYGEN_ARGS}? @{$options->{KEYGEN_ARGS}}: ();my$diffs=0;my$ctx=0;my@ops;my$hunks=0;my$emit_ops=sub {$output_handler->($style->file_header(@seqs,$options))unless$hunks++;$output_handler->($style->hunk_header(@seqs,@_,$options));$output_handler->($style->hunk (@seqs,@_,$options));$output_handler->($style->hunk_footer(@seqs,@_,$options))};my$dis_a=sub {push@ops,[@_[0,1],"-"];++$diffs ;$ctx=0};my$dis_b=sub {push@ops,[@_[0,1],"+"];++$diffs ;$ctx=0};Algorithm::Diff::traverse_sequences(@seqs,{MATCH=>sub {push@ops,[@_[0,1]," "];if ($diffs && ++$ctx > $ctx_lines * 2){$emit_ops->([splice@ops,0,$#ops - $ctx_lines ]);$ctx=$diffs=0}shift@ops if!$diffs && @ops > $ctx_lines},DISCARD_A=>$dis_a,DISCARD_B=>$dis_b,},$options->{KEYGEN},@keygen_args,);if ($diffs){$#ops -= $ctx - $ctx_lines if$ctx > $ctx_lines;$emit_ops->(\@ops)}$output_handler->($style->file_footer(@seqs,$options))if$hunks;return defined$output ? $output : $hunks}sub _header {my ($h)=@_;my ($p1,$fn1,$t1,$p2,$fn2,$t2)=@{$h}{"FILENAME_PREFIX_A","FILENAME_A","MTIME_A","FILENAME_PREFIX_B","FILENAME_B","MTIME_B" };return "" unless defined$fn1 && defined$fn2;return join("",$p1," ",$fn1,defined$t1 ? "\t" .localtime$t1 : (),"\n",$p2," ",$fn2,defined$t2 ? "\t" .localtime$t2 : (),"\n",)}sub _range {my ($ops,$a_or_b,$format)=@_;my$start=$ops->[0]->[$a_or_b];my$after=$ops->[-1]->[$a_or_b];++$after unless$ops->[-1]->[OPCODE]eq ($a_or_b==A ? "+" : "-");my$empty_range=$start==$after;++$start unless$empty_range;return $start==$after ? $format eq "unified" && $empty_range ? "$start,0" : $start : $format eq "unified" ? "$start,".($after-$start+1): "$start,$after"}sub _op_to_line {my ($seqs,$op,$a_or_b,$op_prefixes)=@_;my$opcode=$op->[OPCODE];return ()unless defined$op_prefixes->{$opcode};my$op_sym=defined$op->[FLAG]? $op->[FLAG]: $opcode;$op_sym=$op_prefixes->{$op_sym};return ()unless defined$op_sym;$a_or_b=$op->[OPCODE]ne "+" ? 0 : 1 unless defined$a_or_b;my@line=($op_sym,$seqs->[$a_or_b][$op->[$a_or_b]]);unless ($line[1]=~ /(?:\n|\r\n)$/){$line[1].= "\n\\ No newline at end of file\n"}return@line}SCOPE: {package Text::Diff::Base;sub new {my$proto=shift;return bless {@_ },ref$proto || $proto}sub file_header {return ""}sub hunk_header {return ""}sub hunk {return ""}sub hunk_footer {return ""}sub file_footer {return ""}}@Text::Diff::Unified::ISA=qw(Text::Diff::Base);sub Text::Diff::Unified::file_header {shift;my$options=pop ;_header({FILENAME_PREFIX_A=>"---",FILENAME_PREFIX_B=>"+++",%$options })}sub Text::Diff::Unified::hunk_header {shift;pop;my$ops=pop;return join("","@@ -",_range($ops,A,"unified")," +",_range($ops,B,"unified")," @@\n",)}sub Text::Diff::Unified::hunk {shift;pop;my$ops=pop;my$prefixes={"+"=>"+"," "=>" ","-"=>"-" };return join "",map _op_to_line(\@_,$_,undef,$prefixes),@$ops}@Text::Diff::Context::ISA=qw(Text::Diff::Base);sub Text::Diff::Context::file_header {_header {FILENAME_PREFIX_A=>"***",FILENAME_PREFIX_B=>"---",%{$_[-1]}}}sub Text::Diff::Context::hunk_header {return "***************\n"}sub Text::Diff::Context::hunk {shift;pop;my$ops=pop;my$a_range=_range($ops,A,"");my$b_range=_range($ops,B,"");my$after;for (my$start=0;$start <= $#$ops ;$start=$after ){$after=$start + 1;my$opcode=$ops->[$start]->[OPCODE];next if$opcode eq " ";my$bang_it;while ($after <= $#$ops && $ops->[$after]->[OPCODE]ne " "){$bang_it ||= $ops->[$after]->[OPCODE]ne $opcode;++$after}if ($bang_it){for my$i ($start..($after-1)){$ops->[$i]->[FLAG]="!"}}}my$b_prefixes={"+"=>"+ "," "=>"  ","-"=>undef,"!"=>"! " };my$a_prefixes={"+"=>undef," "=>"  ","-"=>"- ","!"=>"! " };return join("","*** ",$a_range," ****\n",map(_op_to_line(\@_,$_,A,$a_prefixes),@$ops),"--- ",$b_range," ----\n",map(_op_to_line(\@_,$_,B,$b_prefixes),@$ops),)}@Text::Diff::OldStyle::ISA=qw(Text::Diff::Base);sub _op {my$ops=shift;my$op=$ops->[0]->[OPCODE];$op="c" if grep $_->[OPCODE]ne $op,@$ops;$op="a" if$op eq "+";$op="d" if$op eq "-";return$op}sub Text::Diff::OldStyle::hunk_header {shift;pop;my$ops=pop;my$op=_op$ops;return join "",_range($ops,A,""),$op,_range($ops,B,""),"\n"}sub Text::Diff::OldStyle::hunk {shift;pop;my$ops=pop;my$a_prefixes={"+"=>undef," "=>undef,"-"=>"< " };my$b_prefixes={"+"=>"> "," "=>undef,"-"=>undef };my$op=_op$ops;return join("",map(_op_to_line(\@_,$_,A,$a_prefixes),@$ops),$op eq "c" ? "---\n" : (),map(_op_to_line(\@_,$_,B,$b_prefixes),@$ops),)}1;
TEXT_DIFF

$fatpacked{"Text/Diff/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_DIFF_CONFIG';
  package Text::Diff::Config;use 5.006;use strict;use warnings;our$VERSION='1.44';our$Output_Unicode;BEGIN {$Output_Unicode=$ENV{'DIFF_OUTPUT_UNICODE'}}1;
TEXT_DIFF_CONFIG

$fatpacked{"Text/Diff/Table.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEXT_DIFF_TABLE';
  package Text::Diff::Table;use 5.006;use strict;use warnings;use Carp;use Text::Diff::Config;our$VERSION='1.44';our@ISA=qw(Text::Diff::Base Exporter);our@EXPORT_OK=qw(expand_tabs);my%escapes=map {my$c=$_ eq '"' || $_ eq '$' ? qq{'$_'} : $_ eq "\\" ? qq{"\\\\"} : qq{"$_"};(ord eval$c=>$_)}(map(chr,32..126),map(sprintf("\\x%02x",$_),(0..31,127..255)),"\\t","\\n","\\r","\\f","\\b","\\a","\\e");sub expand_tabs($) {my$s=shift;my$count=0;$s =~ s{(\t)(\t*)|([^\t]+)}{
           if ( $1 ) {
               my $spaces = " " x ( 8 - $count % 8  + 8 * length $2 );
               $count = 0;
               $spaces;
       }
       else {
           $count += length $3;
           $3;
      }
      }ge;return$s}sub trim_trailing_line_ends($) {my$s=shift;$s =~ s/[\r\n]+(?!\n)$//;return$s}sub escape($);SCOPE: {my$escaper=<<'EOCODE';unless (eval$escaper){$escaper =~ s/ *use *utf8 *;\n// or die "Can't drop use utf8;";eval$escaper or die $@}}sub new {my$proto=shift;return bless {@_ },$proto}my$missing_elt=["","" ];sub hunk {my$self=shift;my@seqs=(shift,shift);my$ops=shift;my$options=shift;my (@A,@B);for (@$ops){my$opcode=$_->[Text::Diff::OPCODE()];if ($opcode eq " "){push@A,$missing_elt while@A < @B;push@B,$missing_elt while@B < @A}push@A,[$_->[0]+ ($options->{OFFSET_A}|| 0),$seqs[0][$_->[0]]]if$opcode eq " " || $opcode eq "-";push@B,[$_->[1]+ ($options->{OFFSET_B}|| 0),$seqs[1][$_->[1]]]if$opcode eq " " || $opcode eq "+"}push@A,$missing_elt while@A < @B;push@B,$missing_elt while@B < @A;my@elts;for (0..$#A){my ($A,$B)=(shift@A,shift@B);my$elt_type=$B==$missing_elt ? "A" : $A==$missing_elt ? "B" : $A->[1]eq $B->[1]? "=" : "*";if ($elt_type ne "*"){if ($elt_type eq "=" || $A->[1]=~ /\S/ || $B->[1]=~ /\S/){$A->[1]=escape trim_trailing_line_ends expand_tabs$A->[1];$B->[1]=escape trim_trailing_line_ends expand_tabs$B->[1]}else {$A->[1]=escape$A->[1];$B->[1]=escape$B->[1]}}else {$A->[1]=~ /^(\s*?)([^ \t].*?)?(\s*)(?![\n\r])$/s;my ($l_ws_A,$body_A,$t_ws_A)=($1,$2,$3);$body_A="" unless defined$body_A;$B->[1]=~ /^(\s*?)([^ \t].*?)?(\s*)(?![\n\r])$/s;my ($l_ws_B,$body_B,$t_ws_B)=($1,$2,$3);$body_B="" unless defined$body_B;my$added_escapes;if ($l_ws_A ne $l_ws_B){$added_escapes=1 if$l_ws_A =~ s/\t/\\t/g;$added_escapes=1 if$l_ws_B =~ s/\t/\\t/g}if ($t_ws_A ne $t_ws_B){$added_escapes=1 if$t_ws_A =~ s/ /\\s/g;$added_escapes=1 if$t_ws_B =~ s/ /\\s/g;$added_escapes=1 if$t_ws_A =~ s/\t/\\t/g;$added_escapes=1 if$t_ws_B =~ s/\t/\\t/g}else {$t_ws_A=$t_ws_B=""}my$do_tab_escape=$added_escapes || do {my$expanded_A=expand_tabs join($body_A,$l_ws_A,$t_ws_A);my$expanded_B=expand_tabs join($body_B,$l_ws_B,$t_ws_B);$expanded_A eq $expanded_B};my$do_back_escape=$do_tab_escape || do {my ($unescaped_A,$escaped_A,$unescaped_B,$escaped_B)=map join("",/(\\.)/g),map {($_,escape $_)}expand_tabs join($body_A,$l_ws_A,$t_ws_A),expand_tabs join($body_B,$l_ws_B,$t_ws_B);$unescaped_A ne $unescaped_B && $escaped_A eq $escaped_B};if ($do_back_escape){$body_A =~ s/\\/\\\\/g;$body_B =~ s/\\/\\\\/g}my$line_A=join$body_A,$l_ws_A,$t_ws_A;my$line_B=join$body_B,$l_ws_B,$t_ws_B;unless ($do_tab_escape){$line_A=expand_tabs$line_A;$line_B=expand_tabs$line_B}$A->[1]=escape$line_A;$B->[1]=escape$line_B}push@elts,[@$A,@$B,$elt_type ]}push @{$self->{ELTS}},@elts,["bar"];return ""}sub _glean_formats {my$self=shift}sub file_footer {my$self=shift;my@seqs=(shift,shift);my$options=pop;my@heading_lines;if (defined$options->{FILENAME_A}|| defined$options->{FILENAME_B}){push@heading_lines,[map({("",escape(defined $_ ? $_ : "<undef>"))}(@{$options}{qw(FILENAME_A FILENAME_B)})),"=",]}if (defined$options->{MTIME_A}|| defined$options->{MTIME_B}){push@heading_lines,[map({("",escape((defined $_ && length $_)? localtime $_ : ""))}@{$options}{qw(MTIME_A MTIME_B)}),"=",]}if (defined$options->{INDEX_LABEL}){push@heading_lines,["","","","","=" ]unless@heading_lines;$heading_lines[-1]->[0]=$heading_lines[-1]->[2]=$options->{INDEX_LABEL}}my$four_column_mode=0;for my$cols (@heading_lines,@{$self->{ELTS}}){next if$cols->[-1]eq "bar";if ($cols->[0]ne $cols->[2]){$four_column_mode=1;last}}unless ($four_column_mode){for my$cols (@heading_lines,@{$self->{ELTS}}){next if$cols->[-1]eq "bar";splice @$cols,2,1}}my@w=(0,0,0,0);for my$cols (@heading_lines,@{$self->{ELTS}}){next if$cols->[-1]eq "bar";for my$i (0..($#$cols-1)){$w[$i]=length$cols->[$i]if defined$cols->[$i]&& length$cols->[$i]> $w[$i]}}my%fmts=$four_column_mode ? ("="=>"| %$w[0]s|%-$w[1]s  | %$w[2]s|%-$w[3]s  |\n","A"=>"* %$w[0]s|%-$w[1]s  * %$w[2]s|%-$w[3]s  |\n","B"=>"| %$w[0]s|%-$w[1]s  * %$w[2]s|%-$w[3]s  *\n","*"=>"* %$w[0]s|%-$w[1]s  * %$w[2]s|%-$w[3]s  *\n",): ("="=>"| %$w[0]s|%-$w[1]s  |%-$w[2]s  |\n","A"=>"* %$w[0]s|%-$w[1]s  |%-$w[2]s  |\n","B"=>"| %$w[0]s|%-$w[1]s  |%-$w[2]s  *\n","*"=>"* %$w[0]s|%-$w[1]s  |%-$w[2]s  *\n",);my@args=('','','');push(@args,'')if$four_column_mode;$fmts{bar}=sprintf$fmts{"="},@args;$fmts{bar}=~ s/\S/+/g;$fmts{bar}=~ s/ /-/g;no warnings;return join("",map {sprintf($fmts{$_->[-1]},@$_)}(["bar"],@heading_lines,@heading_lines ? ["bar"]: (),@{$self->{ELTS}},),);@{$self->{ELTS}}=[]}1;
        sub escape($) {
        use utf8;
        join "", map {
            my $c = $_;
            $_ = ord;
            exists $escapes{$_}
            ? $escapes{$_}
            : $Text::Diff::Config::Output_Unicode 
            ? $c
            : sprintf( "\\x{%04x}", $_ );
        } split //, shift;
        }
  
        1;
  EOCODE
TEXT_DIFF_TABLE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use strict;
use warnings;
use App::tmclean;
App::tmclean->new_with_options(@ARGV)->run;

__END__

=encoding utf-8

=head1 NAME

tmclean - cleanup TimeMachine

=head1 SYNOPSIS

    % tmclean [--dry-run] [-days=300/-before=2018/01/01]

=head1 DESCRIPTION

tmclean is command line utility for cleanup TimeMachine.

=head1 INSTALLATION

    % cpanm App::tmclean

or you can get single packed executable file.

    % curl -L https://raw.githubusercontent.com/Songmu/App-tmclean/master/tmclean > /usr/local/bin/tmclean; chmod +x /usr/local/bin/tmclean

=head1 LICENSE

Copyright (C) Songmu.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=head1 AUTHOR

Songmu E<lt>y.songmu@gmail.comE<gt>

=cut

